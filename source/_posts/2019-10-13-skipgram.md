---
author:
  nick: 小蛋子
  link: 'https://github.com/xv44586'
title: Word2Vec之skip-gram
date: 2019-10-13 17:12:24
tags: 
  - word2vec
  - skipgram
categories: NLP
cover: /2019/10/13/skipgram/cover.jpeg
---
<!-- toc -->

# Word2Vec
![Word2Vec](/2019/10/13/skipgram/w2v.jpeg)
<code>Word2vec</code> 主要有两种形式，<code>CBOW</code> 和<code>Skip-gram</code>，其中<code>CBOW</code>是通过上下文context来预测当前位置词，<code>SKip-gram</code>则是通过当前词来预测上下文

# Fake Task

word2vec 实际上分为两部分，1，建立模型，2，通过模型获取词的嵌入向量（隐层参数）。整个过程与自编码器的思想类似，即基于训练数据训练一个神经网络，模型训练好后，并不会用这个模型处理后续的任务，真正需要的是这个模型学到的参数，如隐层的权重矩阵，基于训练数据建模的过程叫“Fake Task”，意味着建模并不是我们最终的目的。
# Train

如何训练我们的神经网络模型？假如我们有一个句子“ The dog barked at the mailman”:
* 首先，我们选择句子中一个词作为我们的input word， 如 dog
* 然后，我们需要定义一个skip_window参数，来指定上下文的大小，即input word 一侧选取词的数量，假如skip_window=2,那将从dog出发向左右两个方向取最近的两个word，即（the, dog,barked,at)，此时的$span = skip_window \* 2 + 1 = 5$
另一个需要定义的参数是num_skips，即从上下文中选取多少个word来作为output word，这个参数应该小于等于$2 \* skip_window$，即最多将所有上下文都作为output，但是不能重复。如设置num_skips = 2,此时从上下文选取2个词作为output，如（the， barked），最终我们将得到两组训练数据（dog, the) (dog, barked)

神经网络将基于这些训练数据输出一个概率分布，这个概率分布代表着在输入数据下，词典中每个词是output的概率。如拿数据（dog， barked）来训练，则模型将会告诉我们每个单词是’barked’的概率大小。
模型的输出概率代表着词典中每个单词有多大可能性跟input word同时出现。举个栗子，如果我们向神经网络模型中输入一个单词“Soviet“，那么最终模型的输出概率中，像“Union”， ”Russia“这种相关词的概率将远高于像”watermelon“，”kangaroo“非相关词的概率。因为”Union“，”Russia“在文本中更大可能在”Soviet“的窗口中出现。
我们将通过给神经网络输入文本中成对的单词来训练它完成上面所说的概率计算。下面的图中给出了一些我们的训练样本的例子。我们选定句子“The quick brown fox jumps over lazy dog”，设定我们的窗口大小为2（window_size = 2），也就是说我们仅选输入词前后各两个词和输入词进行组合。下图中，蓝色代表input word，方框内代表位于窗口内的单词。

![](/2019/10/13/skipgram/train.png)
模型将会从每队单词出现的次数中习得统计结果，模型可能会得到更多的（’soviet’， ‘union’）样本对，而（soviet， dog）这样的组合看到的很少。因此，当模型训练完成后，给定一个单词 soviet，输出结果中union 或者russia会比dog有更高的概率。
# 输入

常用做法是用训练文档构建词汇表，然后再对单词进行one-hot编码。编码后的向量，形如$dog = [0, 0, 1, 0, …0]$, 如果词汇表大小为10000， 那这个向量包含了10000的概率，即为当前词为输入的概率
下图是神经网络结构：

![](/2019/10/13/skipgram/arc.png)
我们基于成对的单词来对神经网络进行训练， 训练样本是（input word， output word）这样的单词对，input word 和 output word都是one-hot编码的向量，最终的模型输出是一个概率分布。
# 隐层

如果我们想要用300个特征来表示一个词（即每个词是300维的向量），即隐层有300个神经元，隐层的权重为$10000 \* 300$的矩阵，下图中的左右两个图代表了不同角度看隐层权重，左图中每列代表一个10000维的词向量与隐层单个神经元的连接权重，右图每行代表了一个单词的词向量。
![](/2019/10/13/skipgram/weights.png)
我们最终的目标就是学习这个隐层权重矩阵。
输入被one-hot编码后，实际上只有一个位置不为0，所以这个向量相当稀疏，那如果我们将$1\*10000$的向量与$10000\*300$的矩阵相乘，相当消耗计算资源，为了高效计算，仅仅会选择矩阵中对应的向量中纬度为1的索引行
![lookup table](/2019/10/13/skipgram/lookup.png)
即实际不会进行矩阵乘法计算，而是根据输入向量中不为0 的维度去索引。这样模型中的隐层权重矩阵便成了一个查找表（lookup table），输出就是输入单词的嵌入词向量
# 输出层

隐层的输出是一个1*300的向量，而输出层是一个softmax回归分类器，他的每个结点将会输出一个0-1之间的值（概率），而结点的概率之和为1.
![](/2019/10/13/skipgram/softmax.png)
我们会发现Word2Vec模型是一个超级大的神经网络（权重矩阵规模非常大）。
举个栗子，我们拥有10000个单词的词汇表，我们如果想嵌入300维的词向量，那么我们的输入-隐层权重矩阵和隐层-输出层的权重矩阵都会有 10000 x 300 = 300万个权重，在如此庞大的神经网络中进行梯度下降是相当慢的。更糟糕的是，你需要大量的训练数据来调整这些权重并且避免过拟合。百万数量级的权重矩阵和亿万数量级的训练样本意味着训练这个模型将会是个灾难（太凶残了）。
Word2Vec的作者在它的第二篇论文中强调了这些问题，下面是作者在第二篇论文中的三个创新：
* 1.  将常见的单词组合（word pairs）或者词组作为单个“words”来处理。
* 2.  对高频次单词进行抽样来减少训练样本的个数。
* 3.  对优化目标采用“negative sampling”方法，这样每个训练样本的训练只会更新一小部分的模型权重，从而降低计算负担。
事实证明，对常用词抽样并且对优化目标采用“negative sampling”不仅降低了训练过程中的计算负担，还提高了训练的词向量的质量。

__word pairs and phases__
一些单词组合的含义和拆开以后具有完全不同的意义，比如 New York，单独的New 和York无法表达这个词组的含义。因此，应该把New York作为一个单独的词组来生成其词向量。
__对高频词抽样__
对于高频词，如 the ，按上面的处理方式会有两个问题：
* 1.  当我们得到成对的单词训练样本时，（dog， the）这样的样本并不会提供更多关于dog的语义信息，因为the 在每个单词的上下文几乎都会出现
* 2.  由于the 这样的高频词出现的概率很大，因此为们将会有大量的（the ， 。。。）这样的训练样本，而这些样本的数量远远超过我们学习the这个单词所需的训练样本数。

如果直接删除掉这些高频词，会有两个问题:
* 1.删除后，the这个单词永远也不会出现在我们的上下文窗口
* 2.训练样本会减少

所以word2vec 采用抽样的方式来解决这种高频词问题。他的基本思想是：对于我们在训练原始文本中遇到的每一个单词，他们都有一定概率被我们从文本中删除掉，而这个被删除的概率与单词的频率有关。
![](/2019/10/13/skipgram/del.png)
wi 是一个单词，$Z(w_i)$是这个单词在所有预料中出现的频次。$P(w_i)$是被保留的概率。
* 当$Z(w_i) <= 0.0026$时,$P(w_i) = 1.0$。当单词在语料中出现的频率小于0.0026时，它是100%被保留的，这意味着只有那些在语料中出现频率超过0.26%的单词才会被采样。
* 当$Z(w_i) = 0.00746$ 时，$P(w_i) = 0.5$，意味着这一部分的单词有50%的概率被保留。
* 当$Z(w_i) = 1.0$ 时，$P(w_i) = 0.033$，意味着这部分单词以3.3%的概率被保留

__负采样__
训练一个神经网络意味着要输入训练样本并且不断的调整神经元的权重，不断提高对目标的准确预测。而vocabulary的大小决定了skip-gram神经网络将拥有大规模的权重矩阵，所有的这些权重需要通过我们数以亿计的样本来训练调整，非常消耗计算资源，并且实际中会非常慢。
负采样解决了这个问题，不同于原本每个训练样本更新所有权重，负采样每次让一个训练样本仅仅更新一部分权重，减小计算量。
对于训练样本（fox，quick），都是经过one-hot编码的，当vocabulary的大小为10000时，我们期望输出对应的quick单词的那个神经元的输出是1，其余9999个都是0，这9999个输出为0的神经元所对应的单词称为negative word
隐层-输出层拥有$300 \*10000$的权重，而负采样时，我们仅仅更新quick 和我们选择的其他5个negative word的结点对应的权重，共6个神经元，$300\* 6 = 1800$ 个权重，相当于只计算了0.06%的权重，计算效率大大提高。
![](/2019/10/13/skipgram/sample.png)
其中f(wi)代表每个单词出现的频次，p(wi)代表被选中的概率。
负采样的C语言实现非常的有趣。unigram table有一个包含了一亿个元素的数组，这个数组是由词汇表中每个单词的索引号填充的，并且这个数组中有重复，也就是说有些单词会出现多次。那么每个单词的索引在这个数组中出现的次数该如何决定呢，由公式$P(w_i) \* table\\_size$，也就是说计算出的负采样概率*1亿=单词在表中出现的次数。
有了这张表以后，每次去我们进行负采样时，只需要在0-1亿范围内生成一个随机数，然后选择表中索引号为这个随机数的那个单词作为我们的negative word即可。一个单词的负采样概率越大，那么它在这个表中出现的次数就越多，它被选中的概率就越大。

# 关于头图
摄于内蒙古乌兰布统