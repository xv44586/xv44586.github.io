---
author:
  nick: 小蛋子
  link: 'https://github.com/xv44586'
title: 分享一个有趣的游戏
date: 2019-12-09 22:35:44
categories: Math
tags: Game
cover: /2019/12/09/longton/ant.gif
---
<!-- toc -->

# Langton的蚂蚁
今天第一次知道了一个有趣的游戏，Langton的蚂蚁，动手自己画了一个后，决定分享一下。这个游戏的有趣体现在两个方面：
- 1：这个游戏是个零玩家游戏，整个过程也十分的简单：有一个像围棋盘一样画满方格的画布，初始时，整个画布都是空白，
一只蚂蚁在画布的某一个地方，如果当前空格为白色，则将当前空格去反，然后左转90度并前进一格；如果当前空格为黑色，则将当前空格颜色去反，然后右转90度并前进一格，如此往复。
- 2：最后的结果非常有意思，开始时，整个画布是复杂无规律的复杂图像，很难想象是这么简单的规则产生的，但当蚂蚁走了一万步以后，整个运动过程进入了循环，而图像也开始变为有规律的图像。

开始的前一百步如上图，到一万步还有点时间，所以为直接跳过中间一万步，给出一万步后的一百步。感兴趣有耐心的可以跑下代码观察一下这个有点神奇的游戏。Have fun！

![](/2019/12/09/longton/ant.gif)
    **前一百步**
    
![](/2019/12/09/longton/ant_r.gif)
    **规律出现后的一百步**

Langlon的蚂蚁游戏代码

```python
# -*- coding: utf-8 -*-
# @Date    : 2019/12/9
# @Author  : mingming.xu
# @File    : test.py
import numpy as np

import matplotlib.pyplot as plt
from matplotlib import animation
import matplotlib.ticker as plticker


class Direction(object):
    D = ['E', 'N', 'W', 'S']

    def __init__(self, position, direct):
        self.direct = direct
        self.position = position

    def go_one_step(self, left=True):
        lr = 1 if left else -1
        direct = self.D[(self.D.index(self.direct) + 1 * lr) % len(self.D)]
        next_position = {
            'E': lambda p: [p[0], p[1] + 1 * lr],
            'N': lambda p: [p[0] - 1 * lr, p[1]],
            'W': lambda p: [p[0], p[1] - 1 * lr],
            'S': lambda p: [p[0] + 1 * lr, p[1]]
        }
        position = next_position[self.direct](self.position)
        return Direction(position=position, direct=direct)


N = 100  # length of matrix
lc, hc = 1, -1  # color for negative and positive


fig, ax = plt.subplots(figsize=(50, 50))
data = np.zeros((N, N)) + lc
data[int(N/2), int(N/2)] *= -1

# remove axis
ax.get_yaxis().set_visible(False) #不显示y轴
ax.get_xaxis().set_visible(False) #不显示x轴

# add text
time_template = 'step = %d'
time_text = plt.text(0.5, N+0.1, '', fontdict={'size': 20, 'color': 'red'})

#add grid
# myInterval = 1
# loc = plticker.MultipleLocator(base=myInterval)
# ax.xaxis.set_major_locator(loc)
# ax.yaxis.set_major_locator(loc)
# ax.grid(which='major', axis='both', linestyle='-')

# imshow
ln = plt.imshow(data, animated=True, cmap='gray')


dct = Direction(position=[int(N / 2), int(N / 2)], direct='N')


def init():
    ax.set_xlim(0, N)
    ax.set_ylim(0, N+5)
    time_text.set_text('')
    return ln, time_text


def move(dct, data):
    '''
    当前为白色方格，则对当前方格取反，左转前进一格；若当前为黑色方格，取反后右转前进一格
    :param dct:
    :param mat:
    :return:
    '''
    pos = dct.position
    if data[pos[0], pos[1]] > 0:
        data[pos[0], pos[1]] *= -1
        dct_ = dct.go_one_step(left=True)
    else:
        data[pos[0], pos[1]] *= -1
        dct_ = dct.go_one_step(left=False)

    return dct_, data


def update(f):
    global dct
    global data
    dct, data = move(dct, data)
    ln.set_data(data)
    time_text.set_text(time_template % f)
    return ln, time_text


def data_gen():
    frame = 0
    max_step = 11000

    while frame < max_step:
        frame += 1
        yield frame


anim = animation.FuncAnimation(fig, update, frames=data_gen, interval=10,
                               init_func=init, blit=True, repeat=False)

anim.save('ant.gif', writer='imagemagick', fps=100)

plt.show()

```

# 关于头图
游戏的前一百步