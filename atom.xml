<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小蛋子</title>
  
  <subtitle>小蛋子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xv44586.github.io/"/>
  <updated>2021-02-20T13:26:37.681Z</updated>
  <id>https://xv44586.github.io/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>辞旧迎新</title>
    <link href="https://xv44586.github.io/2021/02/19/happy-new-year/"/>
    <id>https://xv44586.github.io/2021/02/19/happy-new-year/</id>
    <published>2021-02-18T23:31:19.000Z</published>
    <updated>2021-02-20T13:26:37.681Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#ci-jiu">辞旧</a></li><li><a href="#ying-xin">迎新</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --><p></div><br>在新年这个重要的时间节点上，总应该做些总结与计划，来辞旧迎新，然而我总是懒惰加拖延，到了今天初八才正式开写，所以新的一年，第一个flag就是：希望能找到良药医治一下我的拖延症 - -！</p><h1><span id="ci-jiu">辞旧</span><a href="#ci-jiu" class="header-anchor"></a></h1><p>2020年是神奇的一年，这一年里发生了很多意想不到的事，用网友们的话讲就是这一年总忙着见证历史了。而需要见证的历史太多，大多数我都没关注，所以只记录一下我自己”见证”的历史。<br>首先是过年回家，刚到家我就去县里的药店屯了口罩和感冒药，之后就是持续至今的新冠，而由于新冠初期，大家对其认识很少，所以限制出行，而我也就因此度过了高中以来在家最久的一次”寒假”–整整三个月，直到四月初，才买到了机票回来上班。<br>在家的三个月，对我最大的帮助可能就是心灵治愈了，<code>人间烟火气，最抚凡人心</code><br>虽然在家陪父母，但是后期还是需要正常打卡的，所以我也顺便研究了一下藏文语言模型和文本纠错，也就是这个时期，让我更坚定的想要一台自己的服务器，来实验想法。于是，回到北京后，我就开始调研硬件相关，然后自己动手搭了一台<a href="https://xv44586.github.io/2020/05/05/make-a-computer/">服务器</a>，这里还要感谢一下银翔老哥，帮我报销了2080Ti的钱，哈哈。<br>有了服务器，我就开始<code>放弃幻想，拥抱transformer </code>, 开始了看论文与写demo 的路程，期间参考<a href="https://github.com/bojone/bert4keras.git" target="_blank" rel="noopener">bert4keras</a> 与 <a href="https://github.com/CyberZHG/keras-bert" target="_blank" rel="noopener">keras-bert</a>, 实现了一下Bert，不过中间有次实验结果有些奇怪，为了查问题，API基本上改成bert4keras一致了。后面一些相transformer相关的实验代码基本也都在<a href="https://github.com/xv44586/toolkit4nlp" target="_blank" rel="noopener">toolkit4nlp</a><br>这里还有一个小插曲，王萌老哥带我打了一个脑科学的比赛，我们俩花了一天最后拿了个铜牌，这也让我了解到在很多领域，对机器学习和深度学习还是运用的相当少的，一方面是因为任务形态的原因，一方面也是这些领域接受新事物比较缓慢可能，所以我认为与机器学习做交叉，还是有很多事可以做的。<br>接着就到了十一月，由于看到群里有人讨论小学生解数学题的比赛，就去看了<a href="https://www.datafountain.cn/" target="_blank" rel="noopener">datafountain</a>，然后就写了<a href="https://www.datafountain.cn/competitions/474/datasets" target="_blank" rel="noopener">房产行业问答匹配比赛</a>的baseline：<a href="https://github.com/xv44586/ccf_2020_qa_match" target="_blank" rel="noopener">ccf_2020_qa_match</a>, 其实比赛到这就结束了，我就去看论文了，然而有时候事情就是这么奇妙，很多群里的同学看到我的baseline 邀请我去组队，后来与南大的”钞人小哥”刘猛组队，最终拿了第一还。不过答辩时发现，在看论文与做实验的纬度上，我们应该也是第一了- - ！无论如何，也要感谢一下刘猛小哥，不是他邀请我，我也不会拿到这个金牌。毕竟baseline 我写过不少，但是真的认真打到最后还是第一次～～</p><p>总结一下，去年发生了新冠，直到现在大家还是备受困扰，我个人度过了最爽的一个年假，在NLP 上也有了实足的进步，不过也有很多年初的计划没有完成，比如每周一篇blog，看完花书等。</p><h1><span id="ying-xin">迎新</span><a href="#ying-xin" class="header-anchor"></a></h1><p><code>凡事预则立，不预则废。</code>所以，flag还是要立的，新的一年，希望自己更少一点浮躁，做事能更多一点踏实。</p><ul><li>经典论文还有很多没读，最新的论文又源源不断，所以希望新的一年能找到适合自己的读论文节奏。</li><li>一周一篇blog 可能太困难了，希望能一年写三十篇吧就</li><li>感情上也要更成熟一些，对未来要有更清晰的规划</li><li>有空就多运动</li></ul><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1><p>成都海洋馆的可爱白鲸</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Life" scheme="https://xv44586.github.io/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>ccf问答匹配比赛（下）：如何只用“bert”夺冠</title>
    <link href="https://xv44586.github.io/2021/01/20/ccf-qa-2/"/>
    <id>https://xv44586.github.io/2021/01/20/ccf-qa-2/</id>
    <published>2021-01-20T12:39:29.000Z</published>
    <updated>2021-01-20T14:24:24.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#qian-yan">前言</a><ul><li><a href="#sai-ti">赛题</a></li><li><a href="#qa-pair">QA pair</a></li><li><a href="#qa-point">QA Point</a></li><li><a href="#pattern-exploiting-training-pet">Pattern-Exploiting Training (PET)</a></li><li><a href="#concat">Concat</a></li><li><a href="#focal-loss">focal loss</a></li><li><a href="#dui-kang-xun-lian">对抗训练</a></li><li><a href="#post-training">post training</a></li></ul></li><li><a href="#post-training">Post Training</a><ul><li><a href="#mlm">MLM</a></li><li><a href="#nsp">nsp</a></li><li><a href="#model-adaptive">model-adaptive</a></li><li><a href="#geng-xin-ci-shu">更新次数</a></li><li><a href="#zui-zhong-jie-guo">最终结果</a></li></ul></li><li><a href="#rong-ru-zhi-shi">融入知识</a></li><li><a href="#dui-bi-xue-xi">对比学习</a><ul><li><a href="#fei-jian-du-dui-bi-xue-xi">非监督对比学习</a></li><li><a href="#jian-du-dui-bi-xue-xi">监督对比学习</a></li><li><a href="#shi-yan-jie-guo">实验结果</a></li></ul></li><li><a href="#shu-ju-zeng-qiang">数据增强</a><ul><li><a href="#eda">EDA</a></li><li><a href="#wei-biao-qian">伪标签</a></li><li><a href="#shi-yan-jie-guo-1">实验结果</a></li></ul></li><li><a href="#zi-zheng-liu">自蒸馏</a></li><li><a href="#shuffle-jie-ma">shuffle 解码</a></li><li><a href="#mo-xing-rong-he">模型融合</a></li><li><a href="#shi-yan-zong-jie">实验总结</a></li><li><a href="#bi-sai-jie-guo">比赛结果</a></li><li><a href="#dai-ma">代码</a></li><li><a href="#zui-hou">最后</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --><p></div><br>ccf问答匹配比赛也结束了一段时间了，这篇算是一个下篇吧，总结一下后期优（夺）化（冠）的心路历程。标题中的“bert”指的是bert-base系列模型，包括bert/RoBERTa/NEZHA/MacBERT/ERNIE等，而取这个有点“标题党”的标题的主要原因，也是对答辩看到有些团队使用的bert+xgb这种“大力出奇迹”做法吐个槽。</p><h1><span id="qian-yan">前言</span><a href="#qian-yan" class="header-anchor"></a></h1><p>在<a href="https://xv44586.github.io/2020/11/08/ccf-qa/">上一篇</a>中,笔者对比赛做了简单说明，提出了四种baseline（QA Pair/QA Point/PET/Concat),并做了部分尝试（focal loss/对抗训练/梯度惩罚/kfold/post training),没看过的同学可以先看上篇，这里只简单再介绍一下：</p><h2><span id="sai-ti">赛题</span><a href="#sai-ti" class="header-anchor"></a></h2><p>本次赛题的任务是：给定IM交流片段，片段包含一个客户问题以及随后的经纪人若干IM消息，从这些随后的经纪人消息中找出一个是对客户问题的回答。</p><ul><li>数据示例<br>$$<br>\begin{array}{c|c|c|c|c}<br>\hline<br>\text{对话id} &amp;  \text{客户问题} &amp; \text{经纪人回复id} &amp; \text{经纪人回复内容} &amp; \text{回复标签} \\<br>\hline<br>1 &amp; \text{您好，请问这个户型有什么优缺点} &amp; 1 &amp; \text{你是想看看这套房子是吗} &amp; 0 \\<br>\hline<br>&amp; &amp; \text{2} &amp; \text{在的} &amp;\text{0} \\<br>\hline<br>&amp; &amp; \text{3} &amp; \text{此房房型方正 得房率高 多层不带电梯4/6楼<br>} &amp;\text{1} \\<br>\hline<br>\end{array}<br>$$</li><li>评测标准</li></ul><p>f1：2 * (精度 * 召回) / (精度 + 召回)</p><h2><span id="qa-pair">QA pair</span><a href="#qa-pair" class="header-anchor"></a></h2><p>由于回答列表是不连续的，所以不考虑问答之间的顺序关系，将其拆分为query-answer pair，然后进行判断。<br><img src="/2021/01/20/ccf-qa-2/pair.png" alt="pair"></p><h2><span id="qa-point">QA Point</span><a href="#qa-point" class="header-anchor"></a></h2><p>考虑对话连贯性、相关性，将所有回答顺序拼接后再与问题拼接，组成query-answer list，模型对一个问题的所有答案进行预测。此外，我们还给模型增加了“大局观”，即新增一个任务来预测全局所有回答中是否存在label为 1 的回答。<br><img src="/2021/01/20/ccf-qa-2/point.png" alt="point"></p><h2><span id="pattern-exploiting-training-pet">Pattern-Exploiting Training (PET)</span><a href="#pattern-exploiting-training-pet" class="header-anchor"></a></h2><p>此方案通过增加一个pattern，将任务转换为MLM任务，然后通过pattern的得分来判断对应的类别。<br>如本次比赛可以添加一个前缀pattern：“间接回答问题”/ “直接回答问题”，分别对应label 0 / 1，pattern的得分只需看第一个位置中“间”/“直”两个token的概率谁高即可。对于unlabel data，可以不增加pattern 进行mlm任务，这也在一定程度增加了模型的泛化能力。此外，通过多个不同pattern进行融合也能进一步提高其性能。<br><img src="/2021/01/20/ccf-qa-2/pet.png" alt="pet"></p><h2><span id="concat">Concat</span><a href="#concat" class="header-anchor"></a></h2><p>由于bert 中不同的transformer 层提取到的语义粒度不同，而不同粒度的信息对分类来说起到的作用也可能不同，所以可以将所有粒度的语义信息拼接后作为特征进行分类。<br><img src="/2021/01/20/ccf-qa-2/concat.png" alt="concat"></p><h2><span id="focal-loss">focal loss</span><a href="#focal-loss" class="header-anchor"></a></h2><p>由于针对性回答与非针对性回答在数量上有不小差距，大约3:1，所以也想到尝试在loss上进行调节。<br>最终结果是没有多少提升，猜测样本不均衡的问题影响是非常小的，所以将Binary-Crossentropy训练后的模型在train data上进行了predict，并借鉴之前<a href="https://xv44586.github.io/2020/10/14/focal-loss/">focal loss</a>中的方式分析了一下，画出对应的难易样本分布。根据图形上的分布结果，也证实了之前的猜测。<br><img src="/2021/01/20/ccf-qa-2/focalloss.png" alt="focalloss"></p><h2><span id="dui-kang-xun-lian">对抗训练</span><a href="#dui-kang-xun-lian" class="header-anchor"></a></h2><p>对抗训练主要尝试了<a href="https://kexue.fm/archives/7234" target="_blank" rel="noopener">FGM 方法对Embedding进行扰动</a>，线下对比提升大约一个点上下。<br>线下测试结果：</p><p>$$<br>\begin{array}{c|c}<br>\hline<br>\text{without adt} &amp; \text{with adt} \\<br>\hline<br>\text{0.831} &amp; \text{0.838} \\<br>\end{array}<br>$$</p><h2><span id="post-training">post training</span><a href="#post-training" class="header-anchor"></a></h2><p>上一篇中，提到post training 做的效果不好，然而pet 的效果又很好，两者比较矛盾，所以我也重新阅读了几篇关于优化bert 与post training 相关的论文，重新思考了一下，这篇就从重新做post training开始。</p><h1><span id="post-training">Post Training</span><a href="#post-training" class="header-anchor"></a></h1><p>post training一般包括两部分：Domain-Adaptive training 和 Task-Adaptive training，通过在同领域与任务数据上继续预训练，可以让模型更适应任务，有利于提高模型在下游的性能。而bert 在训练时主要有两个任务：mlm 与nsp ，接下来针对每个任务进行讨论。</p><h2><span id="mlm">MLM</span><a href="#mlm" class="header-anchor"></a></h2><p>在post training 阶段尝试进一步优化的只找到刘知远老师的<a href="https://arxiv.org/abs/2004.09733" target="_blank" rel="noopener">Train No Evil: Selective Masking for Task-Guided Pre-Training</a>，论文里的思路是通过建立一个二分类模型，来有针对性的选择token 来进行mask，不过由于这个方法比较麻烦，需要三个中间模型，所以没有尝试，不过这个论文给出了一个结论：在继续预训练的过程中，优化mask 策略，是可以进一步提高下游性能的。<br>让我们回归一下bert 的mask 策略即后续的改进：<br>$$<br>\begin{array}{c|c|}<br>\hline<br>\text{model} &amp; \text{mask sstrategy} \\<br>\hline<br>\text{bert} &amp; \text{random mask} \\<br>\hline<br>\text{RoBERTa} &amp; \text{dynamic mask} \\<br>\hline<br>\text{RoBERTa-wwm-ext} &amp; \text{whole word mask} \\<br>\hline<br>\text{ERNIE} &amp; \text{entity/phrase mask} \\<br>\hline<br>\text{SpanBERT} &amp; \text{n-gram mask}\\<br>\hline<br>\end{array}<br>$$</p><p>这里笔者思考后认为，不同的mask 策略本质区别是对更多的“固定搭配”进行同时mask，从而降低模型对局部、浅层信息的过拟合，增加任务的难度，提高模型的泛化能力。<br>所谓“固定搭配”，不仅仅包含词，或者说是更广义的“词”。字的固定搭配可以构成词，进一步固定搭配又可以形成短语。比如考虑“好好学习，天天向上”，“08北京奥运会”，如果只mask 其中一部分，是比较“容易”通过剩余的部分来还原的。<br>既然“固定搭配”是更广义的词，这里我们就可以来挖掘这些“固定搭配”了。最简单的方式就是新词/短语挖掘，而新词/短语挖掘最常用的方法是计算左右熵和紧密度，不过这种方式计算量较大，这次比赛笔者舍弃了这种方式，采用借鉴苏神的博客<a href="https://kexue.fm/archives/5476" target="_blank" rel="noopener">最小熵原理（二）：“当机立断”之词库构建</a>中的思路，用PMI表征紧密度，用相邻两个字之间的紧密度判断两者是否存在“固定搭配”,最终未被切分的为一个整体。最后将挖掘出的新词通过jieba 过滤掉已在词库内的，并只保留长度2~5的新词，添加到jieba的词库内。这里选择用jieba 做分词工具的原因是因为笔者用的是NEZHA，而NEZHA在训练时使用的就是jieba 处理的数据，这里与他保持一致，而长度选择上，主要借鉴spanBert中的结论。<br>最后挖掘了2736个新词，而如果是实际工作中，则可以进一步将积累的词也加入。<br><img src="/2021/01/20/ccf-qa-2/new_words.png" alt="new_words"><br>以上的方式中全程没有人为参与，所以新词的质量是无法保证的，即存在词的边界不准确。而此时的全词mask 退化为n-gram mask，依然是一种有效的提升方案。</p><h2><span id="nsp">nsp</span><a href="#nsp" class="header-anchor"></a></h2><p>原始bert 在训练时，句子级别的任务为nsp，而RoBERTa 中给出的结论是句子级别的任务没什么用，所以取消了句子级别的任务；而albert 中则将句子级别的任务切换为sop，而SpanBERT中则切换为sbo。这里笔者认为下游任务是句子级别的分类任务，所以句子级别的任务是有用的，不过由于nsp 会引入大量噪音，所以这里选择sop/aop：在qa pair格式的样本下互换qa(sop)，在q a-list格式的样本下，保持query 在最前面，只shuffle a-list(aop)。</p><p>$$<br>\begin{array}{c|c|c}<br>\hline<br> &amp; \text{without sop/aop} &amp; \text{with sop/aop} \\<br>\hline<br>\text{qa pair} &amp; \text{0.784} &amp; \text{0.79} \\<br>\hline<br>\text{q a-list} &amp; \text{0.799} &amp; \text{0.802} \\<br>\hline<br>\end{array}<br>$$</p><h2><span id="model-adaptive">model-adaptive</span><a href="#model-adaptive" class="header-anchor"></a></h2><p>由于样本的组织方式有qa pair 和 q a-list两种方式，而task 相关的数据是相对较小的，所以这里笔者认为两个阶段的样本组织方式相同的情况下，性能会更好，即：用qa pair格式post training后的模型，来微调qa pair格式的baseline，q a-list格式post training后的模型微调q a-list格式的baseline。</p><h2><span id="geng-xin-ci-shu">更新次数</span><a href="#geng-xin-ci-shu" class="header-anchor"></a></h2><p>这里参考邱锡鹏老师的<a href="http://arxiv.org/abs/1905.05583" target="_blank" rel="noopener">How to Fine-Tune BERT for Text Classification?</a>，实验时每10 个epochs保存一次模型，最后通过在下游任务上的表现，得出与论文中基本一致的结论：更新10K steps左右模型在下游的表现是最好的。<br><img src="/2021/01/20/ccf-qa-2/update.png" alt="update"></p><h2><span id="zui-zhong-jie-guo">最终结果</span><a href="#zui-zhong-jie-guo" class="header-anchor"></a></h2><p>$$<br>\begin{array}{c|c|c}<br>\hline<br> \text{post-train/fine-tuning}&amp; \text{pair} &amp; \text{point} \\<br>\hline<br>\text{pair} &amp; \text{0.79} &amp; \text{0.794} \\<br>\hline<br>\text{point} &amp; \text{0.786} &amp; \text{0.802} \\<br>\hline<br>\end{array}<br>$$</p><p>此时我们认为已经将bert的能力最大化了，于是这里也尝试了在bert 后面接一些复杂的分类层（cnn/rnn/dgcnn/..),发现都无法进一步提高，所以也证实了之前的判断。</p><h1><span id="rong-ru-zhi-shi">融入知识</span><a href="#rong-ru-zhi-shi" class="header-anchor"></a></h1><p>既然从“内部”已经无法进一步提高bert的能力，所以此时尝试融入外部知识来增强。而融合的方式主要尝试了两种：  </p><ul><li><p>最底层注入<br>在Embedding 层融入外部的embedding。优点：更多的交互<br><img src="/2021/01/20/ccf-qa-2/inside.png" alt> </p></li><li><p>最顶层注入<br>在transformer output 层融入外部Embedding。优点：更灵活，不局限外部知识的形式（可以是Embedding，也可以说是其他特征，如手工特征）。<br><img src="/2021/01/20/ccf-qa-2/outside.png" alt></p></li></ul><p>在知识选择上，首先想到的是Graph EMbedding，参考<a href="http://arxiv.org/abs/2004.05707" target="_blank" rel="noopener">VGCN-BERT: Augmenting BERT with Graph Embedding for Text Classification</a>,我们重跑了一下论文的代码，发现无法重现其中的结论，而我对Graph Embedding也不熟，所以放弃了这个方案。<br>然后尝试简单的embedding，即用gensim 在task data上训练了一版词向量(dims=100),作为外部知识来实验。<br>线下测试结果：<br>$$<br>\begin{array}{c|c}<br>\hline<br> \text{model} &amp; \text{score} \\<br>\hline<br>\text{bert} &amp; \text{0.831} \\<br>\hline<br>\text{external-embedding bottom} &amp; \text{0.82} \\<br>\hline<br>\text{external-embedding top} &amp; \text{0.83} \\<br>\hline<br>\end{array}<br>$$</p><p>可以看到，两种方式都是无法进一步提高的，主要原因可能是：1.词向量的质量较差；2.词向量也是bert的“内部”知识；3.融入的方式或者调参没做好。</p><h1><span id="dui-bi-xue-xi">对比学习</span><a href="#dui-bi-xue-xi" class="header-anchor"></a></h1><p>在模型上，还能通过增加新的任务来尝试提高性能。而今年比较热的一个思路就是对比学习，所以这里尝试通过增加一个对比学习任务来提高性能。<br>对比学习的主要思路是拉近到正样本之间的距离，拉远到负样本之间的距离。<br><img src="/2021/01/20/ccf-qa-2/cl.png" alt><br>对比学习主要又分为两种：监督对比学习和分监督对比学习。监督对比学习中，将相同label的样本看做是正例，其他的为负例；而非监督对比学习中，则通过对每个样本构造一对view，view之间互为正例，其他的为负例。</p><h2><span id="fei-jian-du-dui-bi-xue-xi">非监督对比学习</span><a href="#fei-jian-du-dui-bi-xue-xi" class="header-anchor"></a></h2><p>非监督对比学习中，通过互换QA位置，同时随机mask 15% 的token，来构造一对view。</p><ul><li>对应的loss：</li></ul><p><img src="/2021/01/20/ccf-qa-2/sscl.png" alt></p><ul><li>对应的模型：</li></ul><p><img src="/2021/01/20/ccf-qa-2/sscl-model.png" alt></p><h2><span id="jian-du-dui-bi-xue-xi">监督对比学习</span><a href="#jian-du-dui-bi-xue-xi" class="header-anchor"></a></h2><p>这里主要follow <a href="http://arxiv.org/abs/2011.01403" target="_blank" rel="noopener">Supervised Contrastive Learning for Pre-trained Language Model Fine-tuning</a>,修改对应loss.</p><ul><li>loss</li></ul><p><img src="/2021/01/20/ccf-qa-2/scl.png" alt></p><ul><li>model</li></ul><p><img src="/2021/01/20/ccf-qa-2/sc-model.png" alt></p><h2><span id="shi-yan-jie-guo">实验结果</span><a href="#shi-yan-jie-guo" class="header-anchor"></a></h2><ul><li>线下结果：</li></ul><p>$$<br>\begin{array}{c|c}<br>\hline<br> \text{model} &amp; \text{score} \\<br>\hline<br>\text{bert} &amp; \text{0.831} \\<br>\hline<br>\text{self-supervised contrastive learning} &amp; \text{0.80} \\<br>\hline<br>\text{supervised contrastive learning} &amp; \text{0.824} \\<br>\hline<br>\end{array}<br>$$</p><ul><li><p>非监督对比学习结果可视化<br><img src="/2021/01/20/ccf-qa-2/ssc-vis.png" alt></p></li><li><p>监督对比学习结果可视化<br><img src="/2021/01/20/ccf-qa-2/sc-vis.png" alt></p></li></ul><p>可以看到，两种方式都没有带来提升，而可视化图中可以看到，非监督对比学习的效果并不好，存在大量重叠但颜色不同的点，说明对比学习任务的结果不好，这里的原因猜测主要有两点：1.模型的设计与调参时有问题，batch size（32）太小，没有BN 层等，都有可能是性能不好的原因；2.构造view 的方式过于简单粗暴，由于样本长度大多较短，随机mask 后即有可能引入错误的label 信息，又可能引起view 间语义的gap过大，无法互为正例。<br>监督学习效果图中，不同label的数据被分到了不同的簇中，说明对比学习的还是相当不错，不过由于此次比赛中的label 代表的是“是否是针对问题的回答”，label 相同但内涵不同，所以强行将相同label的样本聚合，并不能带来提升。</p><h1><span id="shu-ju-zeng-qiang">数据增强</span><a href="#shu-ju-zeng-qiang" class="header-anchor"></a></h1><p>数据增强主要尝试了两种方式：EDA 和伪标签。</p><h2><span id="eda">EDA</span><a href="#eda" class="header-anchor"></a></h2><p>EDA主要包括四种方式：随机替换、随机删除、随机重复和随机互换。<br>由于词向量质量较差，所以操作时选择从当前句子中随机选取一个词作为“同义词”进行操作。<br>操作比例为10%，每个样本构造四个样本。<br>用训练过的模型对数据进行过滤，保留置信度高(&gt;0.7)的样本。</p><h2><span id="wei-biao-qian">伪标签</span><a href="#wei-biao-qian" class="header-anchor"></a></h2><p>用训练过的模型在test data 上进行预测，对预测结果按0.5 为阈值计算置信度并进行排序，保留前30%的样本加入训练集。 这里没有单纯按置信度过滤样本，是因为模型预测结果大多数大于0.95或小于0.05，而过多的测试数据进入训练集，会导致模型最终的结果是在拟合训练集中的label，而无法带来提高（充分学习后的模型在训练数据上的预测结果自然是训练时的label）。</p><h2><span id="shi-yan-jie-guo">实验结果</span><a href="#shi-yan-jie-guo" class="header-anchor"></a></h2><ul><li>线上结果</li></ul><p>$$<br>\begin{array}{c|c}<br>\hline<br> \text{without DA} &amp; \text{with DA} \\<br>\hline<br>\text{0.802} &amp; \text{0.806} \\<br>\hline<br>\end{array}<br>$$</p><h1><span id="zi-zheng-liu">自蒸馏</span><a href="#zi-zheng-liu" class="header-anchor"></a></h1><p>借助知识蒸馏，我们尝试了自蒸馏方案：即Teacher 与 Student 为同一个模型，Teacher模型先学习一遍后，对训练样本打上soft labels，Student 同时学习true labels 与 soft labels. </p><ul><li><p>soft labels：<br>$$<br>q_i = \frac{exp(\frac{z_i}{T})}{\sum_j exp(\frac{z_j}{T})}<br>$$</p></li><li><p>线下测试结果：<br>$$<br>\begin{array}{c|c}<br>\hline<br>\text{without KD} &amp; \text{with KD} \\<br>\hline<br>\text{0.831} &amp; \text{0.84} \\<br>\hline<br>\end{array}<br>$$</p></li></ul><h1><span id="shuffle-jie-ma">shuffle 解码</span><a href="#shuffle-jie-ma" class="header-anchor"></a></h1><p>对于q a-list 的模型，可以在预测时，对answer list 进行全排列，然后将结果投票，一来可以将answer label之间的影响降低，二来可以在非常小的成本下融合，也算是一种trick。不过此次比赛的数据对顺序比较敏感，shuffle后大多数情况下会降低模型的性能，所以最终融合后结果没提升反而降低了。</p><h1><span id="mo-xing-rong-he">模型融合</span><a href="#mo-xing-rong-he" class="header-anchor"></a></h1><p>为了提高模型的稳定性与泛化能力，我们进行了模型融合。融合时，我们期望模型间能“和而不同”：每个单模型的性能之间差异小（都要接近最优单模型），且模型之间差异尽量大(架构或者优化方案上差异尽量大）。根据以上策略，对QA Pair 与 QA Point两种模型进行融合。</p><h1><span id="shi-yan-zong-jie">实验总结</span><a href="#shi-yan-zong-jie" class="header-anchor"></a></h1><ul><li><p>能work的方案<br>$$<br>\begin{array}{c|c}<br>\hline<br>\text{task-adaptive training} &amp; \text{+1.5%~3%} \\<br>\hline<br>\text{加入新词} &amp; \text{+0.5%~1%} \\<br>\hline<br>\text{加入sop/aop} &amp; \text{+0.1%~0.3%} \\<br>\hline<br>\text{model-adaptive} &amp; \text{+0.5%~0.7%} \\<br>\hline<br>\text{对抗训练} &amp; \text{+0.5%~0.9%} \\<br>\hline<br>\text{EDA} &amp; \text{+0.3%~0.5%} \\<br>\hline<br>\text{模型融合} &amp; \text{+0.5%~0.7%} \\<br>\hline<br>\end{array}<br>$$</p></li><li><p>不能work的方案<br>$$<br>\begin{array}{c|c}<br>\hline<br>\text{external-embedding bottom} &amp; \text{-0.2%~0%} \\<br>\hline<br>\text{external-embedding top} &amp; \text{-0.1%~0%} \\<br>\hline<br>\text{self-supervised contrastive learning} &amp; \text{-0.4%~-0.2%} \\<br>\hline<br>\text{supervised contrastive learning} &amp; \text{-0.1%~0%} \\<br>\hline<br>\text{focal loss} &amp; \text{0%} \\<br>\hline<br>\text{shuffle trick} &amp; \text{-0.15%~0} \\<br>\end{array}<br>$$</p></li><li><p>线下有效但未提交<br>$$<br>\begin{array}{c|c}<br>\hline<br>\text{自蒸馏} &amp; \text{+0.5%~1%} \\<br>\hline<br>\text{伪标签} &amp; \text{+0.1%~0.3%} \\<br>\hline<br>\end{array}<br>$$</p></li></ul><p>对于PET ，在post training后的效果并不是很好，不过由于没有时间了，所以没有继续优化。这里提一下可以优化的点：1.可以增加解码空间；2.增加多个pattern 进行融合的方式尝试优化。笔者本人是比较喜欢PET 这个思路的，统一了两个阶段，所以可做的事还有很多。</p><h1><span id="bi-sai-jie-guo">比赛结果</span><a href="#bi-sai-jie-guo" class="header-anchor"></a></h1><p>比赛最终的线上成绩在A/B 榜均是第一，答辩阶段也得到了第一。</p><ul><li>A榜得分：<br><img src="/2021/01/20/ccf-qa-2/a-result.png" alt></li><li>B榜得分：<br><img src="/2021/01/20/ccf-qa-2/b-result.png" alt></li><li>答辩得分：<br><img src="/2021/01/20/ccf-qa-2/last-result.jpg" alt></li></ul><h1><span id="dai-ma">代码</span><a href="#dai-ma" class="header-anchor"></a></h1><p>比赛相关思路的代码开源在github上：<br><a href="https://github.com/xv44586/ccf_2020_qa_match" target="_blank" rel="noopener">ccf_2020_qa_match</a><br>欢迎大家尝试使用，有问题或者想法可以提issue，一起讨论。</p><h1><span id="zui-hou">最后</span><a href="#zui-hou" class="header-anchor"></a></h1><p>本文主要总结了此次ccf 问答匹配中的实验思路，而其中提出的四种baseline ，可以横向推广至所有的文本分类相关的任务中，而优化相关的方案，则可以应用在所有bert-base 模型上。 从最初打算“白嫖”一份数据，到最终拿到第一，算起来这应该是笔者第一次参加NLP的比赛，所以很幸运也很惊喜。<br>Enjoy！</p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1><p>答辩头图</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://xv44586.github.io/categories/NLP/"/>
    
    
      <category term="Classification" scheme="https://xv44586.github.io/tags/Classification/"/>
    
      <category term="CCF" scheme="https://xv44586.github.io/tags/CCF/"/>
    
      <category term="Competition" scheme="https://xv44586.github.io/tags/Competition/"/>
    
      <category term="QA match" scheme="https://xv44586.github.io/tags/QA-match/"/>
    
  </entry>
  
  <entry>
    <title>重新认识矩阵</title>
    <link href="https://xv44586.github.io/2021/01/12/matrix/"/>
    <id>https://xv44586.github.io/2021/01/12/matrix/</id>
    <published>2021-01-12T13:10:17.000Z</published>
    <updated>2021-01-12T13:46:41.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#shi-me-shi-1">什么是1</a></li><li><a href="#xiang-liang">向量</a></li><li><a href="#ju-zhen">矩阵</a></li><li><a href="#ju-zhen-cheng-fa">矩阵乘法</a></li><li><a href="#xiang-si-ju-zhen">相似矩阵</a></li><li><a href="#xing-lie-shi">行列式</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --></div><p>最近有篇很火的论文bert-flow，其中的flow是出了GAN和VAE之外的第三种生成模型，我竟然是第一次听说，所以引起了我的好奇心，然而看flow模型时，发现里面有一个很重要的概念就是行列式，数学渣太久没碰过他所以再看到有些陌生，于是就找了一些文章来重新学习一下，后来发现了孟岩的认识矩阵系列博客与苏神的新认识矩阵系列博客，看完感觉对矩阵的认识refresh了一下，所以做一些总结记录。</p><h1><span id="shi-me-shi-1">什么是1</span><a href="#shi-me-shi-1" class="header-anchor"></a></h1><p>首先我们来讨论一下，什么是<code>1</code>，所谓1，就是参照物，或者是基，而其他的数字都是在参考他得到的，比如2,2就是2 个1，也就是1<em>2.<br>而1又是一个抽象的东西，你没法直观感受什么是1，只有在参考系下，才能直观感受到什么是1，如1瓶水，1米长，而1 与一米的关系就像类与对象一样。所以在参考系下，2米的含义就是2个1米，1米 </em> 2，即在以1米为基的坐标系下，他在2的“位置”。而5瓶水，对应的含义是在以1瓶水为基的参考系下，<br>他处在5的“位置”。而不同的坐标系，在不同的情况下也有优劣之分，如同样的酒，当用来统计销售额时，我们用“瓶”来统计就比用“杯”来统计方便，而当用来劝酒时，用“杯”就明显比用“瓶”要合适一些。也就是，酒还是那么多酒，但是当你用不同的方式来度量时，得到的结果也是不同的，是有优劣之分的。</p><h1><span id="xiang-liang">向量</span><a href="#xiang-liang" class="header-anchor"></a></h1><p>对于向量$A(a, b)$,其对应的含义是在直角坐标系（以$\vec{i}=(1,0),\vec{j}=(0,1)$为基）中，A是在x轴上为a,y轴上为b的点。<br>比如，在以x轴为斤y轴为瓶的直角坐标系（以$\vec{i}=(一斤,0瓶), \vec{j}=(0斤,1瓶)$为基）中，三瓶500毫升的肥仔水对应的向量就是B(3,3).所以，<code>所谓向量即在线性空间内，选定一组基后，用来刻画一个对象</code>。</p><h1><span id="ju-zhen">矩阵</span><a href="#ju-zhen" class="header-anchor"></a></h1><p>那何为矩阵呢？比如对于矩阵<br>$$A=\begin{pmatrix}<br>a &amp; c \\<br>b &amp; d<br>\end{pmatrix}$$<br>我们能观察到什么呢？首先，矩阵也是由向量（列向量）组成的，对于当前矩阵A，也就对应着$\vec{i}=(a,b),\vec{j}=(c,d)$ 两个向量，然后将他们按一定的顺序排列就组成了矩阵；此外，这个矩阵又代表了由这两个向量为基组成的坐标系（线性空间），在这个空间内，所有的对象都能通过这两个基来进行刻画，即对应于一个“向量”。这里如何更直观的理解呢？还是考虑之前的例子，同样是酒，我们可以用“杯”来度量，也可以用“瓶”来度量，假如我们用“杯”作为最初的基，<br>那矩阵对应的就是“瓶”作为基构成的坐标系，而构成矩阵的向量又是在以“杯”为基下度量出来的，其对应的向量中的值的含义就是“瓶”的基在“杯”这个基下的表示，<br>同样的酒，假如在“杯”坐标系下为10（杯），通过这个矩阵，就变为了2（瓶），<code>即矩阵是线性空间里变换（运动）的描述。</code></p><h1><span id="ju-zhen-cheng-fa">矩阵乘法</span><a href="#ju-zhen-cheng-fa" class="header-anchor"></a></h1><p>那何为矩阵乘法呢？比如现在有矩阵<br>$$<br>A=\begin{pmatrix}<br>a &amp; c \\<br>b &amp; d<br>\end{pmatrix}<br>$$<br>向量$x=(e,f)$,对于$Ax$这个矩阵与向量的乘法，这个是什么含义呢？上面我们已经提到了，矩阵是由列向量组成的，而列向量又可以看做是对应坐标系下的一组基，那根据之前我们提到向量与基的关系，就是在基确定后，用来刻画其空间内对象的，对应的就是乘法，那这个矩阵与向量的乘法，我们也可以用这种方式来看待，即矩阵与向量的乘法代表的是在矩阵对应的列向量为基组成的空间内，由向量刻画的对象。这也是为什么矩阵乘法要求对应维度要相等，<br>对应的就是需要用所有的基，才能正确刻画在这组基对应坐标系下的位置（对象）。而矩阵与向量乘法就是用新的基来刻画对象，<code>也即矩阵与向量的乘法代表施加变换。</code></p><p>那为什么矩阵的乘法公式里为对应行与列相乘并求和呢？这是因为最终的结果，我们是需要变换到对应的直角坐标系下的，因为我们书写出来的所有向量，都默认是在直角坐标系下的结果，所以我们需要将结果向量在每个轴上进行分解，然后合并得到最终的结果，对应的就是行与列相乘后求和。</p><p>那何为矩阵与矩阵的乘法呢？如$A * B$,同理，矩阵与矩阵的乘法也可以看做是连续变换后，构造的新的坐标系。矩阵是由向量组成的，而矩阵与向量乘法的含义是在新的基下刻画的对象表示，所以矩阵与矩阵的乘法，对应B这个变换在施加了A这个变换后，形成的新的变换，而施加这个变换，对应B中的列向量都是在A坐标下刻画得到的。</p><p>那何为线性方程呢？比如$Ax = y$, 对应的线性方程是什么含义呢？这个方程左侧有向量有矩阵，而右侧缺只有向量，有点不和谐，我们变换一下，让他们形式一样，$Ax = Iy$,这样，等式成立，两边形式也一样。那写成这个变换，我们就能猜到这个方程中等式的意义了：在直角坐标系($I$)下的y向量，在A坐标系下该如何刻画(x)呢？那再来看看这个方程的解，即$x = A^{-1}y$，而这个式子可以理解为将施加的变换“逆”着再变回去，就还原了原始位置。</p><p>普通乘法有交换律、结合律、分配律，那矩阵乘法是否也满足呢？对于交换律，矩阵乘法是不满足的，想象一下，5“瓶”酒换成“杯”可能是25，而5“杯”酒换成“瓶”，可能也就是1了，所以两个变换交换位置，得到的是不同的变换；而结合律与分配律是满足的，结合律可以看做是将变换分成“几步”走，即先进行“子变换a”,在进行“子变换b”，几步走与一步到位的结果是一致的；而分配律也是类似的思路。</p><h1><span id="xiang-si-ju-zhen">相似矩阵</span><a href="#xiang-si-ju-zhen" class="header-anchor"></a></h1><p>那何为相似矩阵呢？假设有一个矩阵A，对应$y=Ax$, 而现在有一个新的坐标系P，对应有${y}’=B{x}’$,在P坐标系下，x与y对应着$P{x}’=x$, $P{y}’=y$,代入后得到：$P{x}’=AP{y}’ = P(P^{-1}AP){x}’$，即在P坐标系下，从${x}’$ 到${y}’$的变换用矩阵$B=P^{-1}AP$来表示，这就是相似矩阵，<a href="https://spaces.ac.cn/archives/1777" target="_blank" rel="noopener">即同一个线性变换在不同坐标系下的一个测量结果而已。</a></p><h1><span id="xing-lie-shi">行列式</span><a href="#xing-lie-shi" class="header-anchor"></a></h1><p>行列式是在通过<a href="https://zhuanlan.zhihu.com/p/37111386" target="_blank" rel="noopener">高斯消元法解线性方程组时引入的数学工具</a>, 对应的定义为：<br>$$<br>D = \sum(-1)^t a_{1p_n}a_{2p_n}…a_{np_n}<br>$$<br>其中$t$为排列$a_{1p_n}a_{2p_n}…a_{np_n}$的逆序数，$\sum$ 为对所有可能的排列求和。<br>这个计算方式看起来好奇怪，还有一个逆序数，无法直观的理解，那怎么才能有个直观印象，让我们知道为什么这里是这么计算的呢？<br>说实话我虽然几年前在网易云课堂重新学了一遍线性代数，但是今天又基本全忘记了，所以这次，我希望找到一些更“直观”的东西。<br>如果按照矩阵就是对应坐标系的变换，也就是对应基的变换的思路，那矩阵的行列式应该是对应着变换的某种度量（实际是对应坐标系的缩放，也就是基的体积变换）。顺着这个思路，苏神的一篇博文<a href="https://kexue.fm/archives/2208" target="_blank" rel="noopener">新理解矩阵5：体积=行列式</a>中，通过两者的性质相同，证明了行列式的几何意义，就是其对应的n维平行n维体的体积。<br>知道了这个，我们就可以尝试通过计算平行n维体的体积来“直观”感受一下了。<br><img src="/2021/01/12/matrix/det.png" alt></p><p>这里我们讨论二维空间，如上图所示，其中$\overrightarrow{A}$与$\overrightarrow{B}$分别代表两个向量，而其围成的面积S 为(O,A,I,B)四个点所围成的图形。而这个图形又可以看成两个部分的组合：一部分为与四边形(O,D，P,G)重叠的部分，另一部分为剩下的部分。而剩下的部分又可以通过$PI$切分为两个三角形：$\bigtriangleup BPI$ $\bigtriangleup API$，<br>我们分别做两个三角形的高（蓝色线）$PJ=b, PK=c$，此时我们将$\bigtriangleup BPI$ 与 $\bigtriangleup ODA$ 进行对比，两者的高都是$b$,而底的差为$c$，也就是$S\bigtriangleup ODA - S\bigtriangleup BPI = S\bigtriangleup OCM$， 类似的，我们可以求出$S\bigtriangleup OBG - S\bigtriangleup API = S\bigtriangleup OFM$,于是，我们就可以得到一个结论：<br>$$<br>S_{\square OAIB} = S_{\square ODPG} - S_{\square OCMF} = ad - bc = \begin{Vmatrix}<br>a &amp;b \\<br>c &amp; d<br>\end{Vmatrix} = det(A,B)<br>$$</p><p>而两个四边形的位置都是由向量在坐标轴上投影后确定的，也就是对应着行列式中的“排列相乘”，而面积不足需要被“减掉”的小面积就对应逆序数，所以完整的过程就是“通过排列求长方形的面积，然后用大面积减去小面积”。<br>以上的思路可以推广到N维空间，思想是一样的。 而理解了矩阵的行列式就是平行N维体的体积后，对应行列式的计算公式也就显得相当“直观”了。如，对行列式的某一列乘上$\alpha$，则对应的行列式的值也乘上$\alpha$，这里就是对应其中的一个基向量放大了$\alpha$倍，所以体积放大了$\alpha$倍。</p><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>本文主要是参考了许多文章后，发现将矩阵看做是变换的表述这个视角下，很多相关问题都变得非常直观又容易理解，最后经过思考做的部分总结，如果对矩阵感兴趣或者总觉得不容易理解，推荐孟岩的<a href="http://blog.csdn.net/myan/article/details/647511" target="_blank" rel="noopener">理解矩阵系列</a>、苏神的<a href="[https://kexue.fm/archives/1765">新理解矩阵系列</a>、<a href="https://www.matongxue.com/madocs/247/" target="_blank" rel="noopener">马同学的矩阵与行列式系列</a></p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Math" scheme="https://xv44586.github.io/categories/Math/"/>
    
    
      <category term="Math" scheme="https://xv44586.github.io/tags/Math/"/>
    
      <category term="Matrix" scheme="https://xv44586.github.io/tags/Matrix/"/>
    
  </entry>
  
  <entry>
    <title>如何提升bert在下游任务中的性能</title>
    <link href="https://xv44586.github.io/2020/11/24/fine-tune/"/>
    <id>https://xv44586.github.io/2020/11/24/fine-tune/</id>
    <published>2020-11-24T13:44:12.000Z</published>
    <updated>2020-11-25T13:45:14.081Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#further-pre-training">Further Pre-training</a><ul><li><a href="#er-jie-duan-vs-san-jie-duan-vs-si-jie-duan">二阶段 vs 三阶段 vs 四阶段</a><ul><li><a href="#san-jie-duan">三阶段</a></li><li><a href="#si-jie-duan">四阶段</a></li></ul></li></ul></li><li><a href="#ru-he-further-pre-training">如何further pre-training</a><ul><li><a href="#how-to-mask">how to mask</a></li><li><a href="#when-to-stop">when to stop</a></li><li><a href="#how-to-fine-tuning">how to fine-tuning</a><ul><li><a href="#optimizer">optimizer</a></li><li><a href="#learning-rate">learning rate</a></li><li><a href="#multi-task">multi-task</a></li><li><a href="#which-layer">which layer</a></li></ul></li></ul></li><li><a href="#self-knowledge-distillation">Self-Knowledge Distillation</a></li><li><a href="#zhi-shi-zhu-ru">知识注入</a></li><li><a href="#shu-ju-zeng-qiang">数据增强</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --></div><p>随着Transformer 在NLP中的表现，Bert已经成为主流模型，然而大家在下游任务中使用时，是不是也会发现模型的性能时好时坏，甚至相同参数切换一下随机种子结果都不一样，又或者自己不管如何调，模型总达不到想象中的那么好，那如何才能让Bert在下游任务中表现更好更稳呢？本文以文本分类为例，介绍几种能帮你提高下游任务性能的方法。</p><h1><span id="further-pre-training">Further Pre-training</span><a href="#further-pre-training" class="header-anchor"></a></h1><p>最稳定也是最常用的提升下游任务性能的手段就是继续进行预训练了。</p><h2><span id="er-jie-duan-vs-san-jie-duan-vs-si-jie-duan">二阶段 vs 三阶段 vs 四阶段</span><a href="#er-jie-duan-vs-san-jie-duan-vs-si-jie-duan" class="header-anchor"></a></h2><p>首先回顾一下，Bert 是如何使用的呢？我们设通用泛化语料为$D_g$，下游任务相关的数据为$D_t$, Bert 即在通用语料$D_g$ 上训练一个通用的Language Model， 然后利用这个模型学到的通用知识来做下游任务，也就是在下游任务上做fine-tune，这就是<code>二阶段模式</code>。大多数情况下我们也都是这么使用的：下载一个预训练模型，然后在自己的数据上直接fine-tune。</p><h3><span id="san-jie-duan">三阶段</span><a href="#san-jie-duan" class="header-anchor"></a></h3><p>在论文<a href="http://arxiv.org/abs/1801.06146" target="_blank" rel="noopener">Universal Language Model Fine-tuning for Text Classification</a>中，作者提出了一个通用的范式ULMFiT：</p><ol><li><em>在大量的通用语料上训练一个LM（Pretrain）；</em></li><li><em>在任务相关的小数据上继续训练LM（Domain transfer）；</em></li><li><em>在任务相关的小数据上做具体任务（Fine-tune）。</em></li></ol><p>那我们在使用Bert 时能不能也按这种范式，进行三阶段的fine-tune 从而提高性能呢？答案是：<code>能！</code><br>比如邱锡鹏老师的论文<a href="http://arxiv.org/abs/1905.05583" target="_blank" rel="noopener">How to Fine-Tune BERT for Text Classification?</a>和<a href="arXiv:2004.10964 [cs]" target="_blank" rel="noopener">Don’t Stop Pretraining: Adapt Language Models to Domains and Tasks</a>中就验证了，在任务数据$D_t$ 继续进行pretraining 任务，可以提高模型的性能。<br>那如果我们除了任务数据没有别的数据时，怎么办呢？简单，任务数据肯定是相同领域的，此时直接将任务数据看作相同领域数据即可。所以，在进行下游任务之前，不妨先在任务数据上继续进行pre-training 任务继续训练LM ，之后再此基础上进行fine-tune。</p><h3><span id="si-jie-duan">四阶段</span><a href="#si-jie-duan" class="header-anchor"></a></h3><p>我们在实际工作上，任务相关的label data 较难获得，而unlabeled data 却非常多，那如何合理利用这部分数据，是不是也能提高模型在下游的性能呢？答案是：<code>也能！ </code>  </p><ol><li><em>在大量通用语料上训练一个LM（Pretrain）；</em></li><li><em>在相同领域$D_{in_domain}$上继续训练LM（Domain transfer）；</em></li><li><em>在任务相关的小数据上继续训练LM（Task transfer）；</em></li><li><em>在任务相关数据上做具体任务（Fine-tune）。</em>  </li></ol><p>而且上述两篇论文中也给出了结论：先Domain transfer 再进行Task transfer 最后Fine-tune 性能是最好的。</p><h1><span id="ru-he-further-pre-training">如何further pre-training</span><a href="#ru-he-further-pre-training" class="header-anchor"></a></h1><h2><span id="how-to-mask">how to mask</span><a href="#how-to-mask" class="header-anchor"></a></h2><p>首先，在further pre-training时，我们应该如何进行mask 呢？不同的mask 方案是不是能起到更好的效果呢？<br>在Roberta 中提出，动态mask 方案比固定mask 方案效果更好，此外，在做Task transfer 时，由于数据通常较小，固定的mask 方案通常也容易过拟合，所以further pre-training 时，动态随机mask 方案通常比固定mask 效果更好。<br>而ERNIE 和 SpanBert 中都给出了结论，更有针对性的mask 方案可以提升下游任务的性能，那future pre-training 时是否有什么方案能更有针对性的mask 呢？<br>刘知远老师的论文<a href="http://arxiv.org/abs/2004.09733" target="_blank" rel="noopener">Train No Evil: Selective Masking for Task-Guided Pre-Training</a>就提出了一种更有针对性的mask 方案<code>Selective Mask</code>,进行further pre-training 方案，该方案的整体思路是：</p><ol><li><em>在$D_t$上训练一个下游任务模型 $Model_0$;</em></li><li><em>利用$Model_0$判断token 是否是下游任务中的重要token，具体计算公式为：$S(w_i) = P(y_t|s) - P(y_t|s^{‘}_{i-1}W_i)$, 其中$s$为完整句子（序列），$s^{‘}$为一个初始化为空的buffer，每次将句子中的token 往buffer中添加，如果加入的token 对当前任务的表现与完整句子在当前任务的表现差距小于阈值，则认为该token 为重要token，并从buffer 中剔除；</em></li><li><em>利用上一步中得到的token label，训练一个二分类模型$Model_b$，来判断句子中的token 是否为重要token；</em></li><li><em>利用$Model_b$，在domain 数据上进行预测，根据预测结果进行mask ；</em></li><li><em>进行Domain transfer pre-training；</em></li><li><em>在下游任务进行Fine-tuning。</em><br>上述方案验证了更有针对性的mask 重要的token，下游任务中能得到不错的提升。综合下来，<code>Selective Mask &gt; Dynamic Mask &gt; Static Mask</code>   </li></ol><p>虽然selective mask 有提升，但是论文给出的思路太过繁琐了，本质上是判断token 在下游任务上的影响，所以这里给出一个笔者自己脑洞的一个方案：通过$Model_0$在unlabeled 的Domain data 上直接预测，然后通过不同token 下结果的熵的波动来确定token 对下游任务的影响。这个方案我没有做过实验，有兴趣的可以试试。  </p><h2><span id="when-to-stop">when to stop</span><a href="#when-to-stop" class="header-anchor"></a></h2><p>在further pretraining 时，该何时停止呢？是否训练的越久下游任务就提升的越多呢？答案是否定的。在进行Task transfer 时，应该训练多少步，论文<a href="http://arxiv.org/abs/1905.05583" target="_blank" rel="noopener">How to Fine-Tune BERT for Text Classification?</a>进行了实验，最后得出的结论是<code>100k</code>步左右，下游任务上提升是最高的，这也与我自己的实验基本吻合，训练过多就会过拟合，导致下游任务上提升小甚至降低。</p><p><img src="/2020/11/24/fine-tune/step.png" alt></p><p>此外，由于下游任务数据量的不同，进行多少步结果是最优的也许需要实验测试。这里给出一个更快捷稳妥的方案：借鉴PET本质上也是在训练MLM 任务，我们可以先利用利用PET做fine-tuning，然后将最优模型作为预训练后的模型来进行分类任务fine-tuning，这种方案我实验后的结论是与直接进行Task transfer性能提升上相差不大。不了解PET的可以查看我之前博文<a href="https://xv44586.github.io/2020/10/25/pet/">PET-文本分类的又一种妙解</a>.</p><h2><span id="how-to-fine-tuning">how to fine-tuning</span><a href="#how-to-fine-tuning" class="header-anchor"></a></h2><p>不同的fine-tuning 方法也是影响下游任务性能的关键因素。</p><h3><span id="optimizer">optimizer</span><a href="#optimizer" class="header-anchor"></a></h3><p>关于优化方案上，Bert 的论文中建议使用与bert 预训练时一致的方案进行fine-tuning，即使用weighted decay修正后的Adam，并使用warmup策略 搭配线性衰减的学习率。不熟悉的同学可以查看我之前的博文<a href="https://xv44586.github.io/2020/08/01/optimizer-in-bert/">optimizer of bert</a></p><h3><span id="learning-rate">learning rate</span><a href="#learning-rate" class="header-anchor"></a></h3><p>不合适的learning rate可能会导致<code>灾难性遗忘</code>,通常learning rate 在$[-e^{-5}, 1e^{-4}]$之间，更大的learning rate可能就会发生灾难性遗忘，不利于优化。</p><p><img src="/2020/11/24/fine-tune/lrt.png" alt></p><p>此外，对transformer 逐层降低学习率也能降低发生灾难性遗忘的同时提升一些性能。</p><h3><span id="multi-task">multi-task</span><a href="#multi-task" class="header-anchor"></a></h3><p>Bert在预训练时，使用了两个task：NSP 和 MLM，那在下游任务中，增加一个辅助的任务是否能带来提升呢？答案是否定的。如我之前尝试过在分类任务的同时，增加一个相似性任务：让样本与label desc的得分高于样本与其他样本的得分，但是最终性能并没有得到提升。具体的实验过程请看博文<a href="https://xv44586.github.io/2020/09/13/classification-label-augment/">模型增强之从label下手</a>。<br>此外，论文<a href="http://arxiv.org/abs/1905.05583" target="_blank" rel="noopener">How to Fine-Tune BERT for Text Classification?</a>也任务multi-task不能带来下游任务的提升。</p><h3><span id="which-layer">which layer</span><a href="#which-layer" class="header-anchor"></a></h3><p>Bert的结构上是一个12层的transformer，在做文本分类时，通常我们是直接使用最后一层的<code>[CLS]</code>来做fine-tuning，这样是最优的吗？有没有更好的方案？<br>论文<a href="http://arxiv.org/abs/1905.05583" target="_blank" rel="noopener">How to Fine-Tune BERT for Text Classification?</a>中针对这个问题也做了实验，对比了不同的layer不同的抽取策略，最终结论是所有层拼接效果最好，但是与直接使用最后一层差距不大。<br><img src="/2020/11/24/fine-tune/layer.png" alt></p><p>而论文<a href="http://arxiv.org/abs/2008.06460" target="_blank" rel="noopener">Hate Speech Detection and Racial Bias Mitigation in Social Media based on BERT model</a>中，作者通过组合多种粒度的语义信息，即将12层的<code>[CLS]</code>拼接后，送人CNN，在Hate Speech Detection 中能带来<code>8个点</code>的提升！<br><img src="/2020/11/24/fine-tuning/cnn.png" alt></p><p>所以在fine-tuning时，也可以想一想到底是哪种粒度的语义信息对任务更重要。</p><h1><span id="self-knowledge-distillation">Self-Knowledge Distillation</span><a href="#self-knowledge-distillation" class="header-anchor"></a></h1><p>self-knowledge distillation（自蒸馏）也是一种常用的提升下游任务的手段。做法是先在Task data上fine-tuning 一个模型，然后通过模型得到Task data 的soft labels，然后使用soft labels 代替hard label 进行fine-tuning。更多细节可以查看之前的博文<a href="https://xv44586.github.io/2020/08/31/bert-01/">Knowledge Distillation之知识迁移</a> </p><h1><span id="zhi-shi-zhu-ru">知识注入</span><a href="#zhi-shi-zhu-ru" class="header-anchor"></a></h1><p>通过注入外部知识到bert中也能提升Bert的性能，常用的方式主要有两种：</p><ol><li><em>在bert embedding 层注入：通过将外部Embedding 与Bert token-embedding 拼接（相加）进行融合，然后进行transformer一起作用下游；</em></li><li><em>在transformer的最后一层，拼接外部embedding，然后一起作用下游。</em><br>如<a href="http://arxiv.org/abs/1909.08402" target="_blank" rel="noopener">Enriching BERT with Knowledge Graph Embeddings for Document Classification</a>中，通过在<br>transformer的最后一层中拼接其他信息，提高模型的性能。<br><img src="/2020/11/24/fine-tune/kg.png" alt></li></ol><h1><span id="shu-ju-zeng-qiang">数据增强</span><a href="#shu-ju-zeng-qiang" class="header-anchor"></a></h1><p>NLP中数据增强主要有两种方式：一种是保持语义的数据增强，一种是可能破坏语义的局部扰动增强。保持语义通常采用回译法，局部扰动的通常使用EDA，更多细节可以查看之前博文<a href="https://xv44586.github.io/2020/11/10/eda/">NLP中的数据增强</a></p><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>本文总结了使用bert 时，当前主要的提升Bert 在下游任务上的性能的方法，遇到相关问题时，可以尝试一下。</p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://xv44586.github.io/categories/NLP/"/>
    
    
      <category term="BERT" scheme="https://xv44586.github.io/tags/BERT/"/>
    
  </entry>
  
  <entry>
    <title>Contrastive Learning</title>
    <link href="https://xv44586.github.io/2020/11/23/scl/"/>
    <id>https://xv44586.github.io/2020/11/23/scl/</id>
    <published>2020-11-23T13:21:36.000Z</published>
    <updated>2020-11-23T15:13:38.168Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#dui-bi-xue-xi">对比学习</a></li><li><a href="#dui-bi-xue-xi-de-zi-jian-du-xue-xi">对比学习的自监督学习</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --><p></div><br>最近看了两篇关于对比学习（Contrastive Learning）的论文，觉得思路挺有意思，所以总结一下。</p><h1><span id="dui-bi-xue-xi">对比学习</span><a href="#dui-bi-xue-xi" class="header-anchor"></a></h1><p>不知道大家有没有小时候抽读课文的回忆，当读到不认识读字时，我们就会猜他的发音。猜的时候呢，通常就是先看看他的组成部分里有没有认识的，如果有，则读认识的部分的发音，即读<code>半边</code>, 如果拆开的部分不是独立的字，那我们就会联想一下有哪些字跟他有共同的部分，然后那些字都是如何发音的。即便到了现在，遇到不认识的字，我依然会使用这种方法去<code>读</code>. 而这背后的原理其实就是我们认为，该字（样本x）与其相似的字（距离更近的样本）具有相同的发音（label）。这样一个没有经过多少学习的<code>模型</code>却在很多时候都是奏效的。<br>而对比学习与这有着相似的含义：我们在学习表示的时候，不需要完完全全的学习样本的细节，只需要让样本相对其正样本的得分远远大于其相对负样本的得分即可：<br>$$<br>s(f(x), f(x^+)) &gt;&gt; s(f(x),f(x^-))<br>$$<br>其中 $f$是映射函数，也是我们的主要学习任务，$s$是一个打分函数，用来衡量样本之间的距离，最常用的如点积。<br>以上就是一个对比学习的框架，而要使用对比学习，核心问题只有两个：</p><ol><li>如何定义目标函数，上面提到的点积就是一种比较简单通用的方式，此外，还可以用triple-loss等。</li><li>如何构造正负样本，正负样本的构造，合理的正负样本，才能让学到的表示更好的作用在下游任务上。</li></ol><p>此外，如果熟悉Word2Vec的同学也会发现，其实负采样也在对比学习的范畴中，即在使用负采样训练Word2Vec 时，我们的优化目标是让正样本对之间的概率尽可能的大，而其与负样本之间的概率尽可能小，也即拉近正样本对之间的距离。其中定义的目标函数使用的是点积，而正样本的构造是通过窗口大小来选取，负样本的构造即负采样。</p><h1><span id="dui-bi-xue-xi-de-zi-jian-du-xue-xi">对比学习的自监督学习</span><a href="#dui-bi-xue-xi-de-zi-jian-du-xue-xi" class="header-anchor"></a></h1><p>目前学习表示的主流是自监督学习，那为了引入对比学习，我们就需要构造样本的正负样本，其中可以将所有非自己的样本都认为是负样本，需要拉远，那如何构造正样本呢？答案是data augmentation（数据增强）。在CV 中通常用旋转、裁剪等</p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://xv44586.github.io/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>跨界之阿尔滋海默病的分类竞赛</title>
    <link href="https://xv44586.github.io/2020/11/21/ad-dti/"/>
    <id>https://xv44586.github.io/2020/11/21/ad-dti/</id>
    <published>2020-11-21T09:25:24.000Z</published>
    <updated>2020-11-24T16:23:06.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#bi-sai-jie-shao">比赛介绍</a></li><li><a href="#shu-ju-te-dian">数据特点</a></li><li><a href="#si-lu">思路</a></li><li><a href="#jie-lun">结论</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --></div><p>几周前受小王萌的邀请，参加了天津大学医学部组织的一场关于<a href="https://mp.weixin.qq.com/s/KlJOOvwqXkD1ANoVG2AOuw" target="_blank" rel="noopener">利用DTI影像进行阿尔滋海默病的分类竞赛</a>，结果虽然只得了第四名，但是这也是第一次跨界参加比赛，所以总结一下。</p><h1><span id="bi-sai-jie-shao">比赛介绍</span><a href="#bi-sai-jie-shao" class="header-anchor"></a></h1><p>弥散磁共振影像（DTI）在<code>阿尔茨海默病（Alzheimer’s disease, AD）</code>中应用广泛，从DTI影像中提取扩散参数可以用来描述白质结构的完整性，进而显示AD中脑白质的退化模式。利用机器学习的方法可以比较有效的对AD进行诊断和分类。所以比赛的内容是希望选手通过给定的18条主要的脑白质纤维束的扩散指标作为特征，建立并评估出对AD和健康人群的最优分类模型，如果有可能，进一步探索对轻度认知损害患者的预测性能。<br>说成通俗一点就是给定由18个扩散指标组成的一系列特征，然后希望选手通过这些特征来对正常人与病人进行建模，而轻度患者由于比较难区分，所以，如果可能就继续做关于病人/轻度患者/正常人的分类模型。</p><h1><span id="shu-ju-te-dian">数据特点</span><a href="#shu-ju-te-dian" class="header-anchor"></a></h1><p>本次的数据虽然是18个扩散指标，实际上拿到的是沿18条脑内主要纤维束上100个点的8种不同的指标，即每个纤维束上有8种不同指标，每个指标是按顺序固定间隔采样的100个点，合起来每个样本有$18 <em> 8 </em> 100 $个 基础特征。而样本包含三个类别才700个左右。所以此次的数据是一个样本少而基础特征特别多。<br>按每一百个点为一个集合，通过简单的统计，大多数均值方差都在0～1之间，也有几个为负值，还有几个为几百的大数。同时有部分数据为nan。</p><h1><span id="si-lu">思路</span><a href="#si-lu" class="header-anchor"></a></h1><p>基于上述特点，首先要解决的是样本数量太少的问题，其次需要解决特征太多的问题。<br>针对特征太多的问题，可以看作是高维数据，这里我们采样SVM 与 XGBoost两种方案来做，SVM在高维稀疏数据上效果相对较好，而XGBoost我们将其看作是一个特征选择器（encoder），然后在其后面接一个LR进行分类。<br>此外，特征过多我们也尝试了两种平滑方案，将每一百个点的集合进行降纬。1. 对每一百个点的集合上，每十个点进行求均值方差来代替原始特征.  2. 对全量样本按label 求取其中心点，然后求取其对三个中心点的 <cdoe>Wasserstein Distance.<br>针对样本少的问题，也尝试了两种方案：1. 利用GAN 来生成，这个方案是借鉴之前看到的一篇利用GAN 来做CONV-19 的文章，其中由于样本过少，通过GAN 进行生成新样本后，提高了模型的性能；另一个方案是互换相同label 的样本之间的特征，这个方案是由GAN 联想到的，即GAN 实际上在生成分布类似的特征，然后组合成新样本，与其通过一个模型生成相同分布然后组合，不然直接互换，这样他们一定是同分布的。<br>此外，我们还尝试了利用CNN 来提取样本特征然后进行分类。</cdoe></p><h1><span id="jie-lun">结论</span><a href="#jie-lun" class="header-anchor"></a></h1><ol><li>SVM上效果实际比XGB 略差一些，所以最后没有采样SVM。</li><li>XGB的效果最后，尤其是将其看作特征提取器，在后面接了一个分类器的模型。</li><li>平均方差平滑与WD 效果类似，最后保留了WD </li><li>GAN 的效果较差，一来是特征过多，二来是对GAN 不怎么熟，不太会调</li><li>随机互换特征效果时好时坏，感觉这也正常，毕竟特征之间是有关系的</li><li>深度学习在这种数据上基本不收敛</li></ol><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>本篇主要是总结一下跨界参加的一个脑科学比赛，出发点是觉得如果能有什么好的效果，说不定能做点贡献，实际参加后发现很多领域的问题由于各种各样的限制，实际上应用机器学习时还是有很大难度的。最后，贴一下排名吧。</p><p><img src="/2020/11/21/ad-dti/result.png" alt></p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1><p>西伯利亚森林猫</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://xv44586.github.io/categories/MachineLearning/"/>
    
    
      <category term="Competition" scheme="https://xv44586.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>NLP中的数据增强</title>
    <link href="https://xv44586.github.io/2020/11/10/eda/"/>
    <id>https://xv44586.github.io/2020/11/10/eda/</id>
    <published>2020-11-10T14:33:41.000Z</published>
    <updated>2020-11-10T15:55:45.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#shu-ju-zeng-qiang">数据增强</a></li><li><a href="#bao-chi-yu-yi-shu-ju-zeng-qiang">保持语义数据增强</a><ul><li><a href="#hui-yi">回译</a></li><li><a href="#sheng-cheng">生成</a></li></ul></li><li><a href="#ju-bu-rao-dong">局部扰动</a><ul><li><a href="#tong-yi-ci-ti-huan">同义词替换</a></li><li><a href="#cha-ru">插入</a></li><li><a href="#shan-chu">删除</a></li><li><a href="#hu-huan">互换</a></li></ul></li><li><a href="#zong-jie">总结</a></li></ul><!-- tocstop --><p></div><br>最近有同学问nlp中如何做data augmentation，这篇总结下目前知道的方法。</p><h1><span id="shu-ju-zeng-qiang">数据增强</span><a href="#shu-ju-zeng-qiang" class="header-anchor"></a></h1><p>数据增强技术已经是图像领域的标配了，如旋转、镜像、翻转等。由于图像本身的特性，通过这些操作后生成的图像虽然与原始图像不同，但其图像的内容确实基本一致的。所以可以增强模型的鲁棒性和泛化能力。<br>而在NLP领域情况确是不同的，因为NLP中改变一个词有可能变为语义完全想反的句子，比如：<code>“这好吃吧”</code> -&gt; <code>“这好吃吗”</code>.<br>所以，NLP中数据增强主要有两种方式：一种是保持语义的数据增强，一种是可能破坏语义的局部扰动增强。</p><h1><span id="bao-chi-yu-yi-shu-ju-zeng-qiang">保持语义数据增强</span><a href="#bao-chi-yu-yi-shu-ju-zeng-qiang" class="header-anchor"></a></h1><p>保持语义的数据增强主要是构造与原句子语义一样的新句子，如回译、生成等。  </p><h2><span id="hui-yi">回译</span><a href="#hui-yi" class="header-anchor"></a></h2><p>回译即将句子从当前语种翻译至新的语种，然后再翻译回来，得到语义相同表达不同的句子。如将句子从中文翻译为英文然后再翻译回中文。可以借助各大互联网平台的免费API来完成。除此之外，还可以多翻译几组中间语种，增加其丰富性。  </p><h2><span id="sheng-cheng">生成</span><a href="#sheng-cheng" class="header-anchor"></a></h2><p>生成的方式即通过样本构建一个生成模型，生成与样本语义相同的句子。如<a href="https://arxiv.org/abs/1906.06045" target="_blank" rel="noopener">Learning to Ask Unanswerable Questions for Machine Reading Comprehension</a> 就是通过生成新的问题来做SQuAD2.0. 此外，之前的文章<a href="https://xv44586.github.io/2020/08/22/qa-augmentation/">利用NLG 增强QA 任务性能</a>里也总结了通过生成问题及问题答案对来增强qa模型性能，不熟悉的可以翻看一下。</p><p>由于两种方式构造的新句子都是与原句子语义相同的句子，所以，这种方式进行数据增强表达模型偏好是：模型应对于不同表达形式的同一语义的文本具有不变性。</p><h1><span id="ju-bu-rao-dong">局部扰动</span><a href="#ju-bu-rao-dong" class="header-anchor"></a></h1><p>局部扰动主要包括同义词替换、插入、删除、互换四种操作，出自论文<a href="http://arxiv.org/abs/1901.11196" target="_blank" rel="noopener">EDA: Easy Data Augmentation Techniques for Boosting Performance on<br>Text Classification Tasks</a>,因为操作简单，所以也叫<code>EDA</code>（Easy Data Augmentation)。下面分别介绍一下这四种策略。</p><h2><span id="tong-yi-ci-ti-huan">同义词替换</span><a href="#tong-yi-ci-ti-huan" class="header-anchor"></a></h2><p>从句子中随机找出1个非停用词，并求出其同义词，然后用同义词替换该词，重复n次操作</p><h2><span id="cha-ru">插入</span><a href="#cha-ru" class="header-anchor"></a></h2><p>从句子中随机找出一个非停用词，并求出其同义词，然后将同义词插入句子中的一个随机位置，重复n次操作。</p><h2><span id="shan-chu">删除</span><a href="#shan-chu" class="header-anchor"></a></h2><p>以概率p，随机删除句子中的每一个单词</p><h2><span id="hu-huan">互换</span><a href="#hu-huan" class="header-anchor"></a></h2><p>随机选择句子中的两个词，然后互换其位置，重复n次。<br>此外，论文中给出了替换删除等操作的比例$\alpha$ 与新增句子数量$n$ 的建议值：<br><img src="/2020/11/10/eda/eda.png" alt>  </p><p>而现在我们通常都使用bert等transformer模型做下游任务，所以删除操作可以使用padding，即删除token但保留其占位，即保留其位置编码；互换操作可以选择更大的span进行；插入和同义词替换操作也可以尝试从当前句子选择一个词代替同义词等。<br>文章开头我们也提到了，对句子中的词进行改变时，很可能得到语义完全相反的句子，那上面这四种方式为何有效呢？首先，句子中引入的新词都是同义词，所以语义不会发生很大的变换，其次，论文作者通过分析发现，虽然构造的新句子变得可能都不是一个通顺的句子了，但其特征空间分布下的label并没有发散，即经过EDA变换后，原始数据一方面引入了很多噪声，扩大了数据集，同时又保持了原有的标签，因而有效的扩大了样本集的信息容量。<br>此外，上面的方式相当于对模型增加了一个正则约束，其所表达的模型偏好是：模型应该对文本的局部噪声不敏感</p><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>以上就是当前NLP中常用的几种数据增强方案，尤其在样本不均衡及小样本任务下，数据增强往往能带来非常不错的提升。所以值得尝试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://xv44586.github.io/categories/NLP/"/>
    
    
      <category term="EDA" scheme="https://xv44586.github.io/tags/EDA/"/>
    
  </entry>
  
  <entry>
    <title>ccf问答匹配比赛</title>
    <link href="https://xv44586.github.io/2020/11/08/ccf-qa/"/>
    <id>https://xv44586.github.io/2020/11/08/ccf-qa/</id>
    <published>2020-11-08T02:44:15.000Z</published>
    <updated>2020-11-14T12:05:11.623Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#bi-sai-shuo-ming">比赛说明</a></li><li><a href="#baseline">baseline</a><ul><li><a href="#qa-pair">qa pair</a></li><li><a href="#point">point</a></li><li><a href="#pet">pet</a></li><li><a href="#update-concat">update: concat</a></li></ul></li><li><a href="#dui-bi">对比</a></li><li><a href="#chang-shi">尝试</a><ul><li><a href="#post-training">Post-training</a></li><li><a href="#focal-loss">focal loss</a></li><li><a href="#dui-kang-xun-lian-yu-ti-du-cheng-fa">对抗训练与梯度惩罚</a></li><li><a href="#tricks">tricks</a></li></ul></li><li><a href="#zong-jie">总结</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --></div><p>这两周玩了一下ccf 2020 中的<a href="https://www.datafountain.cn/competitions/474" target="_blank" rel="noopener">房产聊天问答匹配</a>比赛，虽然还没完赛，但是先总结一下目前的收获。</p><h1><span id="bi-sai-shuo-ming">比赛说明</span><a href="#bi-sai-shuo-ming" class="header-anchor"></a></h1><p>首先，这个比赛的任务是在一系列回答中找到针对客户问题的回答。而客户提问前的对话及回答前的对话都是不可见的，即整个IM信息是不连续的，任务就是在不连续的回答中找到那些针对客户问题的答案。样本示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query: 采荷一小是分校吧。</span><br><span class="line">reply:</span><br><span class="line">  是的  <span class="number">0</span></span><br><span class="line">  杭州市采荷第一小学钱江苑校区，杭州市钱江新城实验学校。  <span class="number">1</span></span><br><span class="line">  这是五楼  <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>可以看到，样本中所谓的针对问题的回答，不仅仅是直接回答问题的答案，而是更有针对性和说明的回答。</p><h1><span id="baseline">baseline</span><a href="#baseline" class="header-anchor"></a></h1><p>模型选择上，baseline全部使用bert，鉴于相对位置编码优于绝对位置编码，所以选择<a href="https://github.com/huawei-noah/Pretrained-Language-Model/tree/master/NEZHA-TensorFlow" target="_blank" rel="noopener">NEZHA</a>作为预训练权重。备选方案Roberta。</p><h2><span id="qa-pair">qa pair</span><a href="#qa-pair" class="header-anchor"></a></h2><p>由于回答是不连续的，所以可以将问题和答案一一对应，组成qa pair，然后分别判断是否是针对问题的回答。</p><p><img src="/2020/11/08/ccf-qa/pair.png" alt="pair"></p><h2><span id="point">point</span><a href="#point" class="header-anchor"></a></h2><p>虽然对话是不连续的，但是是同一个对话，所以不同的回答能相互支撑，提供部分信息，所以，第二种思路就是将同一个问题的所有回答都拼接在当前回答后面，然后同时对每一个回答进行判断。</p><p><img src="/2020/11/08/ccf-qa/point.png" alt="point"></p><h2><span id="pet">pet</span><a href="#pet" class="header-anchor"></a></h2><p>由于预训练模型使用的语料与当前任务所处领域有一定的gap，所以一个比较简单的想法是先在任务语料上进行Post-training，然后再进行fine-tuning。不过，上次我们介绍过<code>Pattern-Exploiting Training</code>,不了解的可以参考<a href="https://xv44586.github.io/2020/10/25/pet/">PET-文本分类的又一种妙解</a>。借鉴PET的方式，我们将posting-training与fine-tuning结合，即在label data上进行pattern exploiting training，在unlable data上进行mlm任务进行post-traing.</p><p><img src="/2020/11/08/ccf-qa/pet.png" alt="pet"></p><p>以上三种baseline的代码放在<a href="https://github.com/xv44586/ccf_2020_qa_match" target="_blank" rel="noopener">ccf_2020_qa_match</a>,感兴趣的可以查阅。</p><h2><span id="update-concat">update: concat</span><a href="#update-concat" class="header-anchor"></a></h2><p>由于bert 不同的transformer 层提取到的语义粒度不同，而不同粒度的信息对分类来说起到的作用也不同，所以可以concat所以粒度的语义信息，拼接后作为特征进行分类。<br><img src="/2020/11/08/ccf-qa/concat.png" alt="concat"></p><h1><span id="dui-bi">对比</span><a href="#dui-bi" class="header-anchor"></a></h1><p>第一种方案（pair-wise），由于缺少一定的上下文信息，加上很多回答都非常短，同时又可能会离提问”较远”，所以效果是最差的，不过线上提交单模型也有0.75左右了，所以bert确实强大！<br>第二种方案（point）中，将所有已知的上下文信息都整合到一起，所以相对上一种有所提升，不过由于这种上下文的可见性，所以也会带来一定的迷惑：即对某一个reply来说，假如其他的reply中有一个是针对性的回答，就有可能会干扰对当前reply的判断。<br>第三种方案（pet）中，通过mlm进行post-training，可以将领域间的gap缩小，同时，由于在训练时”看到”了测试数据，也在一定程度上减小了线上线下的差距，所以性能是最好的，单模型最好能达到0.765左右。</p><h1><span id="chang-shi">尝试</span><a href="#chang-shi" class="header-anchor"></a></h1><h2><span id="post-training">Post-training</span><a href="#post-training" class="header-anchor"></a></h2><p>第一个想法是尝试进行post-training，来提升所有方案的性能。由于问答之间是不连续的，所以在组织语料上进行了不同方式：</p><ol><li>query-reply pair</li><li>query-reply-list pair</li><li>cut-sentence to make pair</li></ol><p>以上文提到的样本为例；</p><ol><li>query-reply pair:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">采荷一小是分校吧。</span><br><span class="line">是的</span><br><span class="line"></span><br><span class="line">采荷一小是分校吧。</span><br><span class="line">杭州市采荷第一小学钱江苑校区，杭州市钱江新城实验学校。</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="2"><li><p>query-reply-list pair</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">采荷一小是分校吧。</span><br><span class="line">是的 杭州市采荷第一小学钱江苑校区，杭州市钱江新城实验学校。  这是五楼</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>cut-sentence to make pair</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">采荷一小</span><br><span class="line">是分校吧。</span><br><span class="line"></span><br><span class="line">是</span><br><span class="line">的</span><br><span class="line"></span><br><span class="line">杭州市采荷第一小学钱江苑校区，</span><br><span class="line">杭州市钱江新城实验学校。</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p>第一种，将同一对话作为同一篇文档顺序排列；第二种，将问题作为单独文档，同一问题的所有回答作为单独文档，第三种，将问题和回答都作为单独文档，同时将其拆分为左右两个部分来做nsp任务。<br>在mask选择上，选择动态mask，即每个epoch都重新选择mask的token。</p><p>最终结果是如果直接使用<code>[CLS]</code>做最终特征，以上三种都不能带来pair-wise方案的提升，反而会带来不小的降低，猜测原因可能与以上三种方式的nsp任务与当前任务的模式不同，所以反而会引起降低。而在bert 后面接其他层（AttentionPooling1D，DGCNN）后能带来大约一个点左右提升。</p><h2><span id="focal-loss">focal loss</span><a href="#focal-loss" class="header-anchor"></a></h2><p>由于针对性回答与非针对性回答在数量上有不小差距，大约3:1，所以也想到尝试在loss上进行调节。<br>最终结果是没有多少提升，最后将普通loss训练后的模型在train data上进行了predict，并借鉴之前<a href="https://xv44586.github.io/2020/10/14/focal-loss/">focal loss</a>中的方式分析了一下，画出对应的难易样本分布。<br><img src="/2020/11/08/ccf-qa/focalloss.png" alt></p><p>上图中不难发现其难样本并不多也不聚集，所以focal loss并不能带来提升。</p><h2><span id="dui-kang-xun-lian-yu-ti-du-cheng-fa">对抗训练与梯度惩罚</span><a href="#dui-kang-xun-lian-yu-ti-du-cheng-fa" class="header-anchor"></a></h2><p>对抗训练与梯度惩罚也是两种比较有效的提升模型泛化性能的方法。其中对抗采用的FGM。<br>最终实验后发现两者都能带来线上线下的提升，尤其是对抗，最高能提升三个点，不过相同参数下结果也会差二个点左右，所以每个模型都要少不了调参的过程，所以适合后期提高时使用。</p><h2><span id="tricks">tricks</span><a href="#tricks" class="header-anchor"></a></h2><p>由于也是第一次做比赛，所以走了不少弯路，也学到了一些trick：</p><ol><li>对样本进行kfold然后训练，得到k个模型再进行ensemble。其中k从5增加到10，也会有提升。这种方式的好处是可以让更多的数据参与到训练，同时多个模型进行投票，也会带来或多或少的提升。</li><li>对数据进行post-training，虽然我的尝试暂时没有起到提升，但是交流时有其他组的同学通过这个方法就达到单模型0.77以上。而我三种方案对比，pet的方式也是最好的，所以也在一定程度上说明这种方式的有效性。</li><li>bert后接新的层，如cnn,dgcnn等。虽然bert的特征提取能力强大，但是在bert后面接一些新的层，总能带来一定的提升，尤其是DGCNN。这种方式可以看作是两种模型的stacking，即利用bert做特征提取，后面的模型在其上做下游任务。</li><li>不同模型进行ensemble，如将上述三种方案进行ensemble，由于不同模型关注点不同，融合后会带来一定提升。</li><li>更大的模型，如bert-xxlarge等。虽然我的显卡没法实验这种方案，但是交流后发现很多同学都是使用的大模型，baseline就可以达到0.77以上了，所以有时候还是需要一些”钞能力”.</li><li>数据清洗与增强。交流中有人提到用外部数据做增强，所以如果有能力，先做清洗与增强，结果也会提升很多。</li></ol><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>以上就是对当前比赛的一些思考与总结，现在单模型最好的成绩为线上<code>0.7779</code>, 虽然只排到61名，不过鉴于我使用的是base模型，同时也是单模型，没有任何其他后续处理，所以结果感觉还行。后续完赛后如果有新的收获再更新一篇吧。最后，附上暂时排名截图。</p><p><img src="/2020/11/08/ccf-qa/leadboard.png" alt></p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://xv44586.github.io/categories/NLP/"/>
    
    
      <category term="QA" scheme="https://xv44586.github.io/tags/QA/"/>
    
      <category term="CCF" scheme="https://xv44586.github.io/tags/CCF/"/>
    
  </entry>
  
  <entry>
    <title>PET-文本分类的又一种妙解</title>
    <link href="https://xv44586.github.io/2020/10/25/pet/"/>
    <id>https://xv44586.github.io/2020/10/25/pet/</id>
    <published>2020-10-25T03:30:31.000Z</published>
    <updated>2020-10-27T13:11:56.892Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#classification-to-nlg">Classification to NLG</a></li><li><a href="#mlm">MLM</a></li><li><a href="#ren-wu-zhuan-huan">任务转换</a></li><li><a href="#pattern-exploiting-training">Pattern-Exploiting Training</a></li><li><a href="#yu-nlg-chai-yi">与NLG差异</a></li><li><a href="#shi-yan">实验</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --><p></div><br>之前的一篇<a href="https://xv44586.github.io/2020/09/13/classification-label-augment/">《模型增强-从label下手》</a>中，我们提到了通过转换label，将分类转换为NLG的方法，而由于性能没有得到增加，所以就没有继续往下做。今天看到两篇文章，思路略微相似，也让我眼前一亮，发现原来我与顶会思路这么近（误），所以总结对比一下。</p><h1><span id="classification-to-nlg">Classification to NLG</span><a href="#classification-to-nlg" class="header-anchor"></a></h1><p>对于分类任务，我们可以将其转换为一个生成任务。比如此时我们有一个样本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"context：'「天天特价房」华庭仁和国际 3室2厅2卫仅售65万', label: '房产', label_id: 0"</span></span><br></pre></td></tr></table></figure></p><p>通常我们直接预测对应的label id，而由于其也有label，所以我们可以将其转换为一个NLG任务，即：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"context：['「天天特价房」华庭仁和国际 3室2厅2卫仅售65万', '房产']"</span></span><br></pre></td></tr></table></figure></p><p>即通过样本生成label对应的token。借助UniLM同时具有NLU与NLG的能力，只需要很小的改动就可以利用BERT做该任务了，对应的示意图如下：<br><img src="/2020/10/25/pet/unilm.png" alt></p><p>不过当时考虑到UniLM中提到seq2seq的训练<code>不能</code>提高NLU的能力，所以当时并没有选择使用MLM来尝试，最后得到的结论是：</p><p>1.<em> 将分类转为生成后，性能基本一致；</em><br>2.<em> 将分类与生成联合起来训练，性能与单个任务性能基本一致。</em></p><h1><span id="mlm">MLM</span><a href="#mlm" class="header-anchor"></a></h1><p>MLM,即Masked Language Model,中文翻译又叫“掩码语言模型”，即以自监督的方式，mask 掉一部分，然后通过剩余的部分来还原被mask 掉的部分，示意图如下：<br><img src="/2020/10/25/pet/mlm.png" alt></p><p>而mask的方式也有多种，如随机选择token进行mask；将token所在的整个词都mask（whole word mask）；或者将某个span内的token都mask掉（span mask）。<br>虽然mlm在预训练任务上已经被证明十分有效，但是通常认为mlm部分的参数是与mlm任务相关的，而通常在下游任务中我们是别的任务，所以会舍弃掉这部分参数，而只使用encoder部分。<br>但是论文<a href="http://arxiv.org/abs/2009.07118" target="_blank" rel="noopener">It’s Not Just Size That Matters: Small Language Models Are Also Few-Shot Learners</a>与<a href="http://arxiv.org/abs/2001.07676" target="_blank" rel="noopener">Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference</a>却告诉我们，mlm不仅有用，在few-shot场景下，通过一下简单的融合手段，性能能超过当前的明星GPT-3.</p><h1><span id="ren-wu-zhuan-huan">任务转换</span><a href="#ren-wu-zhuan-huan" class="header-anchor"></a></h1><p>与之前的思路类似，我们针对分类任务，不再直接对label进行预测，而是预测其label description，即将其转换为完形填空形式的任务，来预测不同label description的概率。<br>而如何转换成完形填空呢？也很简单，我们添加一个简单的语义通顺的描述，然后将其中与分类有关的内容mask掉即可。举个例子：<br>假如我们现在的任务是短文本分类，一个样本为“context：’「天天特价房」华庭仁和国际 3室2厅2卫仅售65万’, label: ‘房产’”，我们添加一个统一的描述句，将其变为：<br>“下面是一则__相关新闻标题: 「天天特价房」华庭仁和国际 3室2厅2卫仅售65万”,其中的空格可选的内容是所有的label description，对应的真实值是”房产”两个字，这样，我们就将分类任务转换为一个完形填空的形式。<br>而添加的方式也可以分为前缀、后缀两种，完整的方式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"以下是一则__相关新闻标题: 「天天特价房」华庭仁和国际 3室2厅2卫仅售65万"</span></span><br><span class="line"><span class="string">"「天天特价房」华庭仁和国际 3室2厅2卫仅售65万，以上是一则__相关新闻标题"</span></span><br></pre></td></tr></table></figure></p><h1><span id="pattern-exploiting-training">Pattern-Exploiting Training</span><a href="#pattern-exploiting-training" class="header-anchor"></a></h1><p>上面我们添加的前缀/后缀句子称为<code>Pattern</code>, 而label description可以有多种方式，比如，对于“房产”这个label，我们也可以用“地产”来表达，对于“娱乐”label，也可以用“八卦”来表达，所以需要一个token到label的映射，这个映射可以是多对一的，这个被称为<code>Verbalizer</code>,所以在预测时可以将多个token的概率结合起来判断其对应的label。<br>由于是few-shot，为了提高性能，作者采用了与Knowledge Distillation类似的思路，具体方案如下：</p><p>1.<em> 对每个Pattern利用多个pre-train model 进行fine-tuning，得到多个模型.其中$loss=L_{ce} + L_{mlm}$;</em><br>2.<em> 将多个模型的结果进行融合，得到一个融合模型Teacher Model；</em><br>3.<em> 利用Teacher Model在大量unlabed数据上进行预测，得到对应的soft labels；</em><br>4.<em> 利用soft labels数据，训练一个常规的分类模型（非MLM模型）。</em></p><p>以上就是论文<a href="http://arxiv.org/abs/2001.07676" target="_blank" rel="noopener">Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference</a>中提到的PET。<br>此外，该论文中还提到了一个改进：iPET。其中的区别是：在ipet中，得到mlm的多个model后，增加一个迭代：每次会从训练mlm的model中抽取一个$m_i$，然后从剩余的model中选取一部分对unlabeled data进行预测，将其中预测结果确定（不是准确，此时意味着结果的熵很小）的部分打上一个fake label，让$m_i$进行训练。重复多次后，融合模型对unlabeled data进行预测，得到一个soft labels data，在此基础上训练一个常规分类器。</p><p>可以看到，PET的方式主要适用label description为有限空间，即选择题，此外，每个样本的label description需要长度相同，而且由于mask之间相互独立，所以长度也不能太长。</p><h1><span id="yu-nlg-chai-yi">与NLG差异</span><a href="#yu-nlg-chai-yi" class="header-anchor"></a></h1><p>在之前的脑洞中，我们将分类任务转变为NLG任务，即利用样本来生成对应的label description，而他与PET中的主要差别主要有几点：</p><p>1.<em> NLG中我们并没有没有限制label description的长度，且不同label对应description也可能是不同长度；</em><br>2.<em> NLG中我们每个token的生成是有依赖关系的，即后面的token会依赖之前的token，所以token长度可以比PET中稍微长一些；</em><br>3.<em> PET中对应的解码空间大大减小，只需要得到label对应token的概率即可;</em><br>4.<em> PET中的pattern可以放在前缀也可以放在后缀，NLG可以看作是后缀PET.</em><br>5.<em> PET 中由于pre-train是mlm任务，所以zero-show性能更好。</em></p><h1><span id="shi-yan">实验</span><a href="#shi-yan" class="header-anchor"></a></h1><p>针对这些差异尝试做了几组实验，验证一下想法。</p><ol><li>NLG中label长度同一且解码时利用PET的方式解码，在few-shot下准确率从$52.4%$上升到$52.9%$，所以生成的label越短，解码空间越小越准确；</li><li>PET前缀pattern下准确率为%53.7%$,所以前缀pattern比后缀性能更好，这也与苏剑林<a href="https://spaces.ac.cn/archives/7764" target="_blank" rel="noopener">《必须要GPT3吗？不，BERT的MLM模型也能小样本学习》</a>的结论一致。</li><li>zero-shot情况下，PET的准确率为$47.2%$, 而NLG只有$17.9%$，考虑到数据集全量下目前最好成绩才$60.7%$,说明PET的方式在zero-shot下效果相当惊人。</li></ol><p>主要实验代码在<a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/classification_pet_seq2seq.py" target="_blank" rel="noopener">classification_pet_seq2seq</a> 与 <a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/classification_tnews_pet.py" target="_blank" rel="noopener">classification_tnews_pet</a></p><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>本文介绍了一种新的转变分类任务获得更好性能的方法：即将分类任务转化为mlm模型进行完形填空，同时与之前脑洞的将分类转变为生成任务进行对比，通过实验验证了两者的差异与有效性。同时也提醒自己，多想几步，也许就能有新的发现。</p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://xv44586.github.io/categories/NLP/"/>
    
    
      <category term="Classification" scheme="https://xv44586.github.io/tags/Classification/"/>
    
      <category term="Few-shot" scheme="https://xv44586.github.io/tags/Few-shot/"/>
    
  </entry>
  
  <entry>
    <title>AdaBelief-更稳定的优化器</title>
    <link href="https://xv44586.github.io/2020/10/25/adabelief/"/>
    <id>https://xv44586.github.io/2020/10/25/adabelief/</id>
    <published>2020-10-25T02:26:54.000Z</published>
    <updated>2020-10-25T03:18:27.710Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#warmup">warmup</a></li><li><a href="#xiu-gai-adam">修改Adam</a></li><li><a href="#you-dian">优点</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --><p></div><br>对<code>Adam</code> 进行改进的算法有很多，今天介绍一篇改动很小改动小效果不错的-<code>AdaBelief</code>。</p><h1><span id="warmup">warmup</span><a href="#warmup" class="header-anchor"></a></h1><p>在bert中第一次见到warmup的使用，而warmup的作用是让训练更稳定，最后收敛的更好。而warmup有效的一个原因是减缓训练初期模型对mini-batch的提前过拟合，同时，在训练初期，由于loss较大，模型还没得到多少训练，不同step 之间的梯度方差较大，而此时如果使用较大的步长更新，则会朝错误的方向走一大步，而随后的模型不断得到训练，对应的梯度不断减小，同时一般我们会采用不断衰减的学习率，这些都导致随着模型的训练，更新的步长不断变小，而前期朝错误方向的一大步更新可能需要后期很多步的更新才能弥补，有时候可能甚至无法弥补，这就导致模型最后收敛在一个不怎么好的局部最优点，而如果在前期时抑制可能出现的大步更新，保持模型保持“小步走”，则可以避免模型在错误方向上的大步更新，而由模型的不断训练调整会正确的轨道。<br>所以一个重要的点是梯度更新方差大时（不同time step），我们需要谨慎行事，防止出现大错步，而方差小时，我们可以大胆一些，因为此时方向上基本一致，所以可以大踏步的往前走。</p><h1><span id="xiu-gai-adam">修改Adam</span><a href="#xiu-gai-adam" class="header-anchor"></a></h1><p>现在让我们来回顾一下Adam更新公式：</p><p>$$<br>\theta_t = \theta_{t-1} - \alpha \frac{m_t}{\sqrt{v_t}}<br>$$</p><p>其中$m_t$是对$g_t$的预测，$v_t$是对$g_t^2$的预测，对应的更新方向为$\frac{m_t}{\sqrt{v_t}}$.<br>$m_t$除了是对$g_t$的预测外，还可以看做是最近一段时间内（大概为$\frac{1}{1-\alpha}$）梯度的均值,而为了表征当前梯度$g_t$所处区域的方差，我们可以使用$belief = \left | g_t - m_t\right |$,即当前梯度距最近一段区域梯度均值的距离。在结合Adam的更新公式，我们可以用$s_t = (g_t - m_t) ^ 2$ 来代替$v_t$,即在方差大的区域更新时减小步长，而在方差小的区域，快步大走，最后的更新公式为：</p><p>$$<br>\theta_t = \theta_{t-1} - \alpha \frac{m_t}{\sqrt{s_t}}<br>$$</p><p>此时的更新方向为$\frac{m_t}{\sqrt{s_t}}$.<br>这就是<a href="https://arxiv.org/pdf/2010.07468.pdf" target="_blank" rel="noopener">AdaBelief Optimizer</a>的核心思想。具体的更新流程与Adam只需要修改一小部分即可：<br><img src="/2020/10/25/adabelief/opt.jpg" alt></p><h1><span id="you-dian">优点</span><a href="#you-dian" class="header-anchor"></a></h1><p>作者在论文中提到AdaBelief能媲美Adam的收敛速度，同时达到SGD的准确率。我做了几个实验，由于是在小数据集上fine-tuning，所以可能不如在大数据集上从头训练效果明显。不过依然可以得到：<br>1.<em>loss上相对Adam更平稳</em><br>2.<em>收敛上比Adam稍快</em><br>3.<em>性能上比Adam更好</em></p><p>loss 对比图<br><img src="/2020/10/25/adabelief/loss.png" alt></p><p>accuracy对比图<br><img src="/2020/10/25/adabelief/acc.png" alt></p><p>实验代码：<a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/classification_adabelief.py" target="_blank" rel="noopener">classification_adabelief</a></p><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>本文介绍一个最新的优化器AdaBelief，并从与论文不同角度解释其主要作用，在实际工作中可以尝试使用AdaBelief，也许能得到比Adam收敛更快性能更好的结果。</p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1><p>算法改进对比图</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://xv44586.github.io/categories/MachineLearning/"/>
    
    
      <category term="Optimizer" scheme="https://xv44586.github.io/tags/Optimizer/"/>
    
  </entry>
  
  <entry>
    <title>pet</title>
    <link href="https://xv44586.github.io/2020/10/22/pet/pet/"/>
    <id>https://xv44586.github.io/2020/10/22/pet/pet/</id>
    <published>2020-10-22T08:54:19.000Z</published>
    <updated>2020-10-26T14:15:48.266Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前的一篇<a href="https://xv44586.github.io/2020/09/13/classification-label-augment/">《模型增强-从label下手》</a>中，我们提到想通过转换label，增加一个任务，来尝试增强分类任务的性能。而其中的主要思路是想通过文本生成对应的label description ，将文本分类任务转换为NLG任务来做，不过当时考虑到UniLM中提到seq2seq的训练<code>不能</code>提高NLU的能力，所以当时并没有选择使用MLM来尝试，最后得到的结论是：</p><ol><li><ul><li>将分类转为生成后，性能基本一致；*</li></ul></li><li><ul><li>将分类与生成联合起来训练，性能与单个任务性能基本一致。*</li></ul></li></ol><p>最近看了两篇将分类任务转化为MLM的论文，也让我眼前一亮，发现原来我与顶会思路这么近（误）</p><h1><span id="mlm">mlm</span><a href="#mlm" class="header-anchor"></a></h1><p>mlm,即Masked Language Model,中文翻译又叫“掩码语言模型”，即以自监督的方式，mask 掉一部分，然后通过剩余的部分来还原被mask 掉的部分，示意图如下：<br><img src="pet/mlm.png" alt></p><p>而mask的方式也有多种，如随机mask选择token进行mask；将token所在的整个词都mask（whole word mask）；或者将某个span内的token都mask掉（span mask）。<br>虽然mlm在预训练任务上已经被证明十分有效，但是通常认为mlm部分的参数是与mlm任务相关的，而通常在下游任务中我们是别的任务，所以会舍弃掉这部分参数，而只使用encoder部分。<br>但是论文<a href="http://arxiv.org/abs/2009.07118" target="_blank" rel="noopener">It’s Not Just Size That Matters: Small Language Models Are Also Few-Shot Learners</a>与<a href="http://arxiv.org/abs/2001.07676" target="_blank" rel="noopener">Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference</a>却告诉我们，mlm不仅有用，在few-shot场景下，通过一下简单的融合手段，性能能超过当前的明星GPT-3.</p><h1><span id="ren-wu-zhuan-huan">任务转换</span><a href="#ren-wu-zhuan-huan" class="header-anchor"></a></h1><p>与之前的思路类似，我们针对分类任务，不再直接对label进行预测，而是预测其label description，即将其转换为完形填空形式的任务，来预测不同label description的概率。<br>而如何转换成完形填空呢？也很简单，我们添加一个简单的语义通顺的描述，然后将其中与分类有关的内容mask掉即可。举个例子：<br>假如我们现在的任务是短文本分类，一个样本为“context：’「天天特价房」华庭仁和国际 3室2厅2卫仅售65万’, label: ‘房产’”，我们添加一个统一的描述句，将其变为：<br>“下面是一则__相关新闻标题: 「天天特价房」华庭仁和国际 3室2厅2卫仅售65万”,其中的空格可选的内容是所有的label description，对应的真实值是”房产”两个字，这样，我们就将分类任务转换为一个完形填空的形式。<br>而添加的方式也可以分为前缀、后缀两种，完整的方式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"以下是一则__相关新闻标题: 「天天特价房」华庭仁和国际 3室2厅2卫仅售65万"</span></span><br><span class="line"><span class="string">"「天天特价房」华庭仁和国际 3室2厅2卫仅售65万，以上是一则__相关新闻标题"</span></span><br></pre></td></tr></table></figure></p><h1><span id="pattern-exploiting-training">Pattern-Exploiting Training</span><a href="#pattern-exploiting-training" class="header-anchor"></a></h1><p>上面我们添加的前缀/后缀句子称为<code>Pattern</code>, 而label description可以有多种方式，比如，对于“房产”这个label，我们也可以用“地产”来表达，对于“娱乐”label，也可以用“八卦”来表达，所以需要一个token到label的映射，这个映射可以是多对一的，这个被称为<code>Verbalizer</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>一切三段成三角形</title>
    <link href="https://xv44586.github.io/2020/10/19/triangle/"/>
    <id>https://xv44586.github.io/2020/10/19/triangle/</id>
    <published>2020-10-19T13:23:48.000Z</published>
    <updated>2020-10-20T15:11:24.993Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#ti-mu">题目</a></li><li><a href="#jie-da">解答</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --></div><p>听到一个题目，还挺有意思，所以记录一下。</p><h1><span id="ti-mu">题目</span><a href="#ti-mu" class="header-anchor"></a></h1><p>问：一个绳子长<code>a</code>，任意剪两刀变成三段后，可以组成一个三角形的概率是多少？</p><h1><span id="jie-da">解答</span><a href="#jie-da" class="header-anchor"></a></h1><p>分析一下题目，一段长度固定的绳子，切割为三段，则：<br>1.<em> 任意一段绳子的长度大于0小于<code>a</code>；</em><br>2.<em> 任意两段绳子的长度大于0小于<code>a</code>。</em></p><p>而三段绳子可以组成一个三角形，而三角形中两边之和大于第三边，所以意味着：<br>1.<em>任意一段的长度小于<code>a/2</code>；</em><br>2.<em>任意两段的长度和大于<code>a/2</code>.</em></p><p>现在设其中两段的长度分别为 <code>x</code>, <code>y</code>，画出一个直角坐标系，如下图所示。<br><img src="/2020/10/19/triangle/triangle.png" alt></p><p>同时连接<code>(0, a), (a, 0)</code>两点，则切割绳子后其中两段的长度的所有可取的值对应由<code>(0, 0),(a, 0), (0, a)</code>组成的三角形区域。<br>简单证明如下：对于任意一点<code>B</code>,我们做其对<code>y</code>轴的垂线，相交与点<code>P</code>,而点<code>B</code>位于<code>(a, 0) (0, a)</code>的连线时，对应$\angle PAB  = 45^o$,此时<br>$PB=PA \Rightarrow  PB + PO = PA + PO = a$,而当<code>P</code>位于连线外侧，则$\angle PAB  &gt; 45^o$,对应$PO + PB &gt; PO + PA = a$,不满足约束。而$\Delta A O C$ 的面积为 $a^2 / 2$.</p><p>而对于能组成三角形时，首先任意一条长度小于$a/2$，对应<code>(0, a/2),(a/2,a/2)</code>连线与<code>(a/2,0)(a/2,a/2)</code>连线围城的矩形区域，而任意两边之和大于$a/2$,利用之前的方法可以证明是(0,a/2)(a/2, 0)连线右侧区域，两者的交即图中绿色三角形区域，其面积为$(a/2)^2/2 = a^2 / 8$</p><p>所以最后结论是组成三角形的概率为两个面积之比：<br>$$<br>pro = \frac{a^2/8}{a^2/2} = 1/4<br>$$</p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Math" scheme="https://xv44586.github.io/categories/Math/"/>
    
    
      <category term="Statistics" scheme="https://xv44586.github.io/tags/Statistics/"/>
    
  </entry>
  
  <entry>
    <title>样本不均衡之难易不均衡</title>
    <link href="https://xv44586.github.io/2020/10/14/focal-loss/"/>
    <id>https://xv44586.github.io/2020/10/14/focal-loss/</id>
    <published>2020-10-14T13:35:55.000Z</published>
    <updated>2020-11-11T14:47:58.900Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#cross-entropy">Cross Entropy</a></li><li><a href="#yang-ben-lei-bie-bu-jun-heng">样本类别不均衡</a></li><li><a href="#focal-loss">Focal Loss</a><ul><li><a href="#ru-he-que-ding-alpha-yu-gamma">如何确定$\alpha$ 与 $\gamma$</a></li><li><a href="#shi-yan">实验</a></li></ul></li><li><a href="#ghm">GHM</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --><p></div><br>上篇<a href="https://xv44586.github.io/2020/09/25/fastbert/">看样本下菜的FastBERT</a>提到样本有难易，通过利用样本的这个特性，可以在推理上进行加速，除了在推理上可以利用，在训练时也可以利用，本篇就来说怎么在训练时更充分的利用样本有难易的特性。</p><h1><span id="cross-entropy">Cross Entropy</span><a href="#cross-entropy" class="header-anchor"></a></h1><p>对于分类问题，通常我们选择交叉熵作为损失。本文均针对二分类进行说明，多分类的情况可以横向扩展。对于二分类问题来说，其损失CE：</p><p>$$<br>CE = \left\{\begin{matrix}<br> -log(p)&amp; y\_true=1  \\<br> -log(1-p),&amp; y\_true=0<br>\end{matrix}\right.<br>$$</p><h1><span id="yang-ben-lei-bie-bu-jun-heng">样本类别不均衡</span><a href="#yang-ben-lei-bie-bu-jun-heng" class="header-anchor"></a></h1><p>当我们遇到一个正负样本不均衡的情况，如1:1000时，直接训练后效果往往不好，其倾向于将更多的样本预测为类别多的类，而产生的原因是：由于我们训练时使用的 CE:<br>$CE_W = CE_positive + CE_negative$, 其中CE_positive 与 CE_negative 分别代表正负样本的loss，而由于此时的样本不均衡，loss主要有类别多的样本贡献，主导了优化方向，所以模型会偏向数量多的方向，如当前全部预测为正样本，那解决这个问题最简单直接的办法就是在loss上增加一个权重α来均衡一下两方的loss，从而让模型更“公平”的对待不同类别样本,即：</p><p>$$<br>CE_W = \left\{\begin{matrix}<br> -\alpha log(p)&amp; y\_true=1  \\<br> -(1-\alpha)log(1-p),&amp; y\_true=0<br>\end{matrix}\right.<br>$$</p><h1><span id="focal-loss">Focal Loss</span><a href="#focal-loss" class="header-anchor"></a></h1><p>除了在类别上可能存在这种不均衡外，样本在难易程度上往往也会有难易之分。如当训练一个情感分类器时，“不喜欢xx”就比“谁不喜欢xx呢”要容易训练一些. 为了衡量这种“难易”特征，我们定义一个代表预测值与真实label 之间差距的参数$p_t$:</p><p>$$<br>p_t = \left\{\begin{matrix}<br> 1-p,&amp; y\_true=1  \\<br> p,&amp; y\_true=0<br>\end{matrix}\right.<br>$$</p><p>即</p><p>$$<br>p_t = \begin{vmatrix}<br>pred - y_{true}<br>\end{vmatrix}<br>$$</p><p>pt越大则说明预测值与其label 相差越大，也即样本越“难训练”，最后我们对整个样本的pt 统计往往得到一个U型分布，如下图所示：<br><img src="/2020/10/14/focal-loss/a1.png" alt><br>即“易训练”样本是“难训练”样本的指数级。虽然此时“易训练”样本由于得到了很好的训练，其loss 很小，当由于其数量庞大，任然可能主动整个训练。<br>所以为了解决难易不均衡的问题，我们采用与样本不均衡一样的方法：对不同样本添加一个权重来平衡，即此时的loss FL:</p><p>$$<br>FL = \left\{\begin{matrix}<br> -\alpha \beta(p\_t) log(p)&amp; y\_true=1  \\<br> -(1-\alpha)\beta(1-p\_t)log(1-p),&amp; y\_true=0<br>\end{matrix}\right.<br>$$</p><p>而前面我们说难易样本的loss 呈指数级差距，所以此时的$\beta(p_t)$ 我们也定义为指数函数，最终的 FL:</p><p>$$<br>FL = \left\{\begin{matrix}<br> -\alpha(1 - p)^{\gamma} log(p)&amp; y\_true=1  \\<br> -(1-\alpha)(p)^{\gamma}log(1-p),&amp; y\_true=0<br>\end{matrix}\right.<br>$$</p><p>此时，$\alpha$ 用来平衡样本不均衡，$(1-p)^{\gamma}$ 用来均衡难易样本。通过平衡难易样本对应损失，让模型更“关注”那些难分的样本。</p><p>以上就是<a href="https://arxiv.org/pdf/1708.02002.pdf" target="_blank" rel="noopener">focal loss</a> 的主要思想，虽然最后我们得到的loss形式上与focal loss一样，但其中参数的含义与focal loss中的内容却有一些不同，主要在于focal loss 中实验证明，由于对难易样本降权后正样本（量少的类）对应的loss反而更易主动优化方向，所以用 $\alpha$ 来降权，而我们上面提到的alpha 主要是用来均衡正负样本，这里读者可以自行判断理解。此外，苏剑林通过硬截断过渡到软阶段也得到了类似的loss，推荐大家也看看：<a href="https://spaces.ac.cn/archives/4733" target="_blank" rel="noopener">从loss的硬截断、软化到focal loss </a></p><h2><span id="ru-he-que-ding-alpha-yu-gamma">如何确定$\alpha$ 与 $\gamma$</span><a href="#ru-he-que-ding-alpha-yu-gamma" class="header-anchor"></a></h2><p>在focal loss论文内，作者是通过搜索一个范围来确定两个参数的最优解，最后给出的结果是 $\alpha = 0.25$, $\gamma=2.$，而通过上面我们提到的两个参数的含义，这里给出一个确定参数范围的方案：<br>1.首先，我们通过统计正负样本，来确定$\alpha$的大致范围；<br>2.通过CE_W我们可以训练一个基础的分类器，通过这个分类器，我们对训练集进行预测，生成对应的prob，然后通过统计$p_t$，我们认为$p_t&lt;=0.1$ 的为主要的“易分样本”，${p_t&gt;=0.9}$ 为主要“难分样本”，由于是指数衰减，所以两者的loss 差距为 $9^\gamma$, 即此时$9^\gamma=C_易/C_难$, 解出此时的$\gamma$ 即可得到其大致的范围。</p><h2><span id="shi-yan">实验</span><a href="#shi-yan" class="header-anchor"></a></h2><p>实验时，通过构造一个正负样本8:1的数据集进行实验，在通过权重平衡正负样本不均衡后，对应的pt分布如下图：<br><img src="/2020/10/14/focal-loss/a1.png" alt><br><img src="/2020/10/14/focal-loss/p1.png" alt><br><img src="/2020/10/14/focal-loss/n1.png" alt><br>而focal loss 训练后的pt 分布为：<br><img src="/2020/10/14/focal-loss/a2.png" alt><br><img src="/2020/10/14/focal-loss/p2.png" alt><br><img src="/2020/10/14/focal-loss/n2.png" alt><br>可以看到，在focal loss 下，右侧偏差大的样本基本都被移到了左侧，说明“难样本”大幅度减少变为了“易样本”。<br>实验代码地址：<a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/classification_focal_loss.py" target="_blank" rel="noopener">classification use focal loss</a></p><h1><span id="ghm">GHM</span><a href="#ghm" class="header-anchor"></a></h1><p>现在让我们来讨论一下focal loss存在的问题：</p><ol><li>首先，让模型过多的关注那些特别难分的样本没有什么问题，但是这个前提：样本紧凑。而当数据中存在离群点时，那此时就会发生：本来模型已经收敛了，但是由于这些离群点还是会误判，一直存在在pt的最右侧，而让模型再过多的去关注这些点，这明显是不合适的；</li><li>对于focal loss中的两个参数$\alpha$ 和$\gamma$ ，虽然我们能估算一个大致范围，但是由于两者是相互影响的，所以实际使用时还是需要通过实验去寻找最优解，这也为训练增加了一定的难度。</li></ol><p>现在再让我们回过头来重新审视一下我们的原始问题：样本有难易之分，所以训练时存在难易样本不均衡，而”易分”样本占比过高导致主导优化方向。那此时让我们往后再思考一步，当我们对易分样本降权后，对应的pt分布图中最左侧的柱子会降低，而由于模型得到了更好的优化方向，模型的性能提高，所以最右侧的柱子也会降低，两边减少的样本会同时向”中间”扩散，最后得到一个比原始pt分布曲线更”平滑”的分布曲线，正如上文中focal loss对应的pt分布图。<br>而focal loss 由于过度关注”难分样本”，导致存在离群点时不理想的问题。而离群点有一个特点就是：量相对正常样本非常少（否则就是一个”小群”了），利用这个特点，我们就能对focal loss 进行改进了。改进的思路就是利用离群点少的特点，从难易样本的量上来平衡难易样本的loss。<br>具体做法：我们将$p_t$ 按间隔$\varepsilon$均等的分为K个区间，然后统计不同区间内的样本数量$num_k$，然后针对每个区间内的loss 我们用参数$\beta(i)$ 来平滑：</p><p>$$<br>L_{GHN-C} = \sum_{1}^{N}\beta(i)L_{CE}(p_i,  \hat p_i)<br>$$</p><p>其中：<br>$\beta(i)$对应$pt_i$所属区间的样本$num_k$在整体样本 $N$ 中占比的倒数。<br>而在实现时，由于通常我们都是采取mini-batch 的方式训练，无法在每个batch内事先得到全局统计量进行$\beta(i)的计算，一种近似的办法是利用动量，逐步近似求。<br>以上就是<a href="http://arxiv.org/abs/1811.05181" target="_blank" rel="noopener">GHM</a> 在分类情况下的loss，原始论文中的pt 分布对比图中也能看到，利用GHM确实更平滑。<br><img src="/2020/10/14/focal-loss/gn.jpeg" alt> </p><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>本文介绍了两种针对样本难易不均衡问题的loss：focal loss 与 GHM，并通过实验进一步验证了其有效性，在一些样本不均衡的场景下均可尝试使用。</p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1><p><a href="https://arxiv.org/pdf/1811.05181.pdf" target="_blank" rel="noopener">Gradient Harmonized Single-stage Detector</a>中配图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://xv44586.github.io/categories/MachineLearning/"/>
    
    
      <category term="样本不均衡" scheme="https://xv44586.github.io/tags/%E6%A0%B7%E6%9C%AC%E4%B8%8D%E5%9D%87%E8%A1%A1/"/>
    
      <category term="Loss" scheme="https://xv44586.github.io/tags/Loss/"/>
    
  </entry>
  
  <entry>
    <title>年轻人的第一个swift：ios 模拟定位打卡</title>
    <link href="https://xv44586.github.io/2020/09/30/location/"/>
    <id>https://xv44586.github.io/2020/09/30/location/</id>
    <published>2020-09-30T14:34:11.000Z</published>
    <updated>2020-09-30T15:10:14.932Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#qi-yin">起因</a></li><li><a href="#mo-ni-ding-wei">模拟定位</a></li><li><a href="#fang-fa">方法</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --></div><h1><span id="qi-yin">起因</span><a href="#qi-yin" class="header-anchor"></a></h1><p>由于最近马上过节了，而我也被这节日的气氛所支配，所以今天完成了未打卡三连成就。公司现在规定每个月只有两次未正常打卡的机会，超过了会有相应的惩罚机制。我感觉自己工作时长接近十个小时，但是因为忘记打卡被处罚的话心里多少有点不爽，所以就想是不是可以补救一下。- -！</p><h1><span id="mo-ni-ding-wei">模拟定位</span><a href="#mo-ni-ding-wei" class="header-anchor"></a></h1><p>很早之前就听说Xcode 提供了模拟定位，方便开发者调试，所以我想这个应该是个切入点，问了一个懂这个大佬，也得到了肯定的答案。<br>所以主体思路是通过Xcode 模拟定位，然后借助这个模拟定位功能，定位到公司附近，然后钉钉打卡。不过网上找到的方法大多数都不是swift 的，我自己摸索了一个小时找到了具体方案，其实非常的简单。</p><h1><span id="fang-fa">方法</span><a href="#fang-fa" class="header-anchor"></a></h1><ol><li><p>首先，通过<a href="https://lbs.amap.com/console/show/picker" target="_blank" rel="noopener">高德</a>/百度地图/腾讯地图获取公司附近经纬度，不过需要注意的是iOS原生坐标为<code>世界标准地理坐标(WGS-84)</code>, 百度地图的坐标为<code>BD-09</code>,高德为<code>中国国测局地理坐标（GCJ-02）</code>,需要将位置转换为iOS 坐标下的。<br>坐标转换有比较简单的方法，GitHub上找到一个<a href="https://github.com/wandergis/coordTransform_py" target="_blank" rel="noopener">coordTransform_py</a>(忽略我是一个GIS专业学生 - -！),对应转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> coordTransform_utils <span class="keyword">import</span>  *</span><br><span class="line">lon, lat = <span class="number">120.177239</span>,<span class="number">30.216698</span></span><br><span class="line">w_lon, w_lat = gcj02_to_wgs84(lon, lat)</span><br></pre></td></tr></table></figure></li><li><p>Xcode 新建一个项目，项目内新建一个gpx 文件，文件内容里添加对应的经纬度：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gpx</span> <span class="attr">version</span>=<span class="string">"1.1"</span> <span class="attr">creator</span>=<span class="string">"Xcode"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     Provide one or more waypoints containing a latitude/longitude pair. If you provide one</span></span><br><span class="line"><span class="comment">     waypoint, Xcode will simulate that specific location. If you provide multiple waypoints,</span></span><br><span class="line"><span class="comment">     Xcode will simulate a route visiting each waypoint.</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wpt</span> <span class="attr">lat</span>=<span class="string">"39.99200300843388"</span> <span class="attr">lon</span>=<span class="string">"116.46688673941635"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Cupertino<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">         Optionally provide a time element for each waypoint. Xcode will interpolate movement</span></span><br><span class="line"><span class="comment">         at a rate of speed based on the time elapsed between each waypoint. If you do not provide</span></span><br><span class="line"><span class="comment">         a time element, then Xcode will use a fixed rate of speed.</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         Waypoints must be sorted by time in ascending order.</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">time</span>&gt;</span>2014-09-24T14:55:37Z<span class="tag">&lt;/<span class="name">time</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">wpt</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">gpx</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>手机与电脑连接，然后让程序在手机上运行起来，同时保持手机定位打开状态，此时就可以通过模拟位置来修改手机的当前定位了。最终打卡成功。</p></li></ol><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>本文是由于未正常打卡紧缺，我尝试补救的一次探索，由于是第一次接触Xcode ，感觉有点兴奋。不过希望看到这里的你不要用这个方法来做坏事。</p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1><p>打卡成功</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Life" scheme="https://xv44586.github.io/categories/Life/"/>
    
    
      <category term="swift" scheme="https://xv44586.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Knowledge Distillation (3) &amp;#58; 看样本下菜的FastBERT</title>
    <link href="https://xv44586.github.io/2020/09/25/fastbert/"/>
    <id>https://xv44586.github.io/2020/09/25/fastbert/</id>
    <published>2020-09-25T14:32:38.000Z</published>
    <updated>2020-10-25T02:55:33.030Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#knowledge-distillation-mu-de">Knowledge Distillation 目的</a></li><li><a href="#zen-me-zuo">怎么做</a><ul><li><a href="#qu-fen-yang-ben">区分样本</a></li><li><a href="#mo-xing-can-shu-gong-xiang">模型参数共享</a></li><li><a href="#zheng-ti-jia-gou">整体架构</a></li></ul></li><li><a href="#fu-xian">复现</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --></div><p>之前Knowledge Distillation 相关的两篇分别介绍了两种知识蒸馏的方式：<a href="https://xv44586.github.io/2020/08/09/bert-of-theseus/">模型替换之bert-of-theseus</a> 和<a href="https://xv44586.github.io/2020/08/31/bert-01/">知识迁移</a>,本篇介绍一种从样本入手的知识蒸馏方法。</p><h1><span id="knowledge-distillation-mu-de">Knowledge Distillation 目的</span><a href="#knowledge-distillation-mu-de" class="header-anchor"></a></h1><p>再来看看我们做knowledge distillation 的目的是什么：我们是想要模型即性能好又推理快，那要推理快，我们直接使用一个更小的模型，比如3层的bert就比12层的bert快，那为什么不这么做呢？这是因为直接用3层bert来fine-tuning的结果往往不那么“性能好”，所以他只能满足推理快这一半。<br>所以我们要通过一个teacher 来引导这个小模型，来把“性能好”这个特性补上。</p><h1><span id="zen-me-zuo">怎么做</span><a href="#zen-me-zuo" class="header-anchor"></a></h1><p>而一般做KD ，我们往往关注怎么去让student 更好的学习teacher，但是好像没人关注过student 直接fine-tuning 的时候到底有多差？拿文本分类来说，我们用bert-3 在IFLYTEK数据上进行fine-tuning，最终的accuracy 大概在57.9%，而bert-12 大概在60.7%((结果)[<a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/classification_ifytek_bert_of_theseus.py])，3层是不如12层，但是差距只有不到3个点，换句不严谨的话说，只有不到3%的数据需要12层的bert才能达到当前最优性能，而大部分样本在前3层就已经能确定了。" target="_blank" rel="noopener">https://github.com/xv44586/toolkit4nlp/blob/master/examples/classification_ifytek_bert_of_theseus.py])，3层是不如12层，但是差距只有不到3个点，换句不严谨的话说，只有不到3%的数据需要12层的bert才能达到当前最优性能，而大部分样本在前3层就已经能确定了。</a><br>换成一句我们都能理解的事实描述就是：样本有难易之分，有的样本容易区分，有的样本不容易区分。这时候，如果全部样本都当不容易区分看待，对这部分容易区分的样本来说就是“杀鸡用牛刀”了，那一个简单直观的办法就是，我们“杀鸡时用杀鸡刀，杀牛时用杀牛刀”，即我们按样本难易程度，分别为他们指定不同的模型来分类，简单的样本只需要用小模型，因为他就能得到与大模型一致的结果，而难的样本再用大模型，这样就能“性能好”的同时推理又快了，因为大部分模型只需要小模型推理即可。</p><h2><span id="qu-fen-yang-ben">区分样本</span><a href="#qu-fen-yang-ben" class="header-anchor"></a></h2><p>接下来的问题就是我们怎么区分样本是简单样本还是难样本了。这里我们将其换个思路：假如小模型对自己的结果非常有信心（确定），那我们就相信小模型的结果，反之，我们就将样本送进大模型，让大模型来进一步判断。注意，这里如果小模型非常“确定”的将样本给了错误结果，那这个结果也将认为是最终结果，即使这个结果送进大模型有被改正确的可能。那如何判断一个结果的不确定性呢？通常我们用熵来判断一个分布的不确定性，这里也一样。</p><h2><span id="mo-xing-can-shu-gong-xiang">模型参数共享</span><a href="#mo-xing-can-shu-gong-xiang" class="header-anchor"></a></h2><p>到了这一步，我们取得了“性能好”又“推理快”的目标了吗？其实还没有，因为此时我们会有多个模型，每个模型对应不同难易程度的样本，这样无疑是将推理从一次变成了多次，那怎么解决呢？我们可以利用上一个小模型的结果而不用再从头算，这样最终的模型就由一系列模型变为一个带有多个分支的大模型，只是每个分支的部分会进行一次判断，如果其结果的不确定性非常低，则直接返回结果而不再往后继续计算。而由于利用了上一层的结果，所以整体的时间上只增加了多个分类器与判断结果置信度的时间，而这个时间相对于其他计算要小的多。</p><h2><span id="zheng-ti-jia-gou">整体架构</span><a href="#zheng-ti-jia-gou" class="header-anchor"></a></h2><p>模型整体架构示意图：<br><img src="/2020/09/25/fastbert/fastbert.png" alt></p><p>以上就是fastbert 模型的整体思路了。对于fastbert 来说，越靠前的层的性能越好，其推理速度提升的就越大，所以有必要尽量提高前面层的性能。这里就是Knowledge Distillation 的任务了：由于fastbert 本身就是一个12层bert，所以将最后一个分类器作为Teacher Model，然后生成对应的soft labels，然后迁移到fastbert 的每一个分支model上。之前的<a href="https://xv44586.github.io/2020/08/31/bert-01/">实验</a>我们也提到过这种self-distillation 能提高性能，作者这里也是一样的思路。</p><h1><span id="fu-xian">复现</span><a href="#fu-xian" class="header-anchor"></a></h1><p>实验代码在<a href="https://github.com/xv44586/Knowledge-Distillation-NLP/blob/master/knowledge_distillation_fastbert.py" target="_blank" rel="noopener">fastbert</a>感兴趣的同学可以看看.不过由于我只会keras(tensorflow)，而tf 这种静态图不好实现这种分支结构，所以我的实验代码其实并没有真的提前终止计算返回结果，暂时没找到更好的实现方式，如果有知道的同学也欢迎告知。</p><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>fastbert从思路上来说，通过对样本进行难易程度进行划分，对样本进行adaptive predict ，但是缺点也比较明显：1. 用确定性来代替难易，中间有不对等会导致较难样本在初期被错分后没有修正对机会；2.其基本假设是易分样本远多于难分样本，否则会使推理速度不降反增。</p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1><p>芝麻街</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://xv44586.github.io/categories/NLP/"/>
    
    
      <category term="Distillation" scheme="https://xv44586.github.io/tags/Distillation/"/>
    
      <category term="FastBERT" scheme="https://xv44586.github.io/tags/FastBERT/"/>
    
  </entry>
  
  <entry>
    <title>模型增强（2）&amp;#58; 从label下手</title>
    <link href="https://xv44586.github.io/2020/09/13/classification-label-augment/"/>
    <id>https://xv44586.github.io/2020/09/13/classification-label-augment/</id>
    <published>2020-09-12T16:09:24.000Z</published>
    <updated>2020-10-25T02:55:33.036Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#gou-zao-xin-label">构造新label</a><ul><li><a href="#zi-jian-du">自监督</a></li><li><a href="#xiang-si-xing">相似性</a></li></ul></li><li><a href="#shi-yan-jie-guo">实验结果</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --></div><p>上篇<a href="https://xv44586.github.io/2020/08/31/bert-01/">Knowledge Distillation (2): distilling knowledge of bert</a>中我们提到，模型压缩时一个很重要的知识是soft labels，<br>并且提出了一种简单的方式：自蒸馏（self-distillation），而从label 的角度来看，可以看作是一种label augmentation，即构造了一个新的label，为模型新增了一个任务，通过新任务的学习，来提高模型对原来任务的性能。本文就label augmentation 继续脑洞。</p><h1><span id="gou-zao-xin-label">构造新label</span><a href="#gou-zao-xin-label" class="header-anchor"></a></h1><p>构造新label，其实本质上是构造一个与当前任务相关的新的任务，而对应的label则是通过当前样本通过某种方式获得，获得的label至少要比随机好，否则只会帮倒忙。</p><h2><span id="zi-jian-du">自监督</span><a href="#zi-jian-du" class="header-anchor"></a></h2><p>构造新label，我们可以借鉴自监督的方式，如Mask Language Model，AutoRegressive，而BERT中已使用来MLM，UniLM中也告诉我们增加Seq2Seq的AR 任务对NLU任务提高不显著，不过今年的论文<a href="http://arxiv.org/abs/2004.10964" target="_blank" rel="noopener">Don’t Stop Pretraining: Adapt Language Models to Domains and Tasks</a> 实验证明了进一步预训练是能进一步提升下游任务的性能。而当前任务是文本分类，MLM也许不是很合适，所以Seq2Seq 的方式可以尝试。<br>具体的，我们让模型学习目标类别的同时，希望模型能同时生成样本的描述字段（或者人为给定的某种相关性短语），即利用类别对应描述字段构造一个seq2seq任务。</p><h2><span id="xiang-si-xing">相似性</span><a href="#xiang-si-xing" class="header-anchor"></a></h2><p>对于同一个类别的样本，他们必然有某种相似性，至少比与其他类别的样本更相似。而何如构造样本呢？<br>一种简单的方式是对每个样本都从类当中抽取一个样本与他组成一对，然后让每个<code>i</code>样本与<code>i+1</code>样本相似。这种方式由于每次样本都是shuffle 的，只要让batch size 小于label number，一个batch 内同时出现多个同一类别的样本概率就会很小。<br>既然在构造seq2seq任务时，我们使用来label对应的描述，此时我们也可以继续尝试使用：每个样本构造一个新的样本，新样本由label对应描述与label id组成。</p><h1><span id="shi-yan-jie-guo">实验结果</span><a href="#shi-yan-jie-guo" class="header-anchor"></a></h1><p>两组实验结果如下：</p><p>$$<br>\begin{array}{c|c|c}<br>\hline \\<br>\text{seq2seq} &amp; \text{similarity} \\<br>\hline \\<br>59.91\% &amp; 56.9\%<br>\end{array}<br>$$</p><p>可以看到，对于构造seq2seq 任务，其结果与直接fine-tuning 结果基本一致，这也符合预期。而构造相似性任务，其结果直接fine-tuning 结果相比反而更差了。原因可能是样本不均衡，所以同一batch 内有较高概率出现同一类别的样本，同时通过让样本与同一样本相似来间接相似，这种方式可能有些曲折了，不过最根本的原因应该还是batch 内同一类别样本的出现干扰了学习。<br>具体实验代码可以查阅<a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/classification_ifytek_auxiliary_seq2seq_task.py" target="_blank" rel="noopener">classification_ifytek_auxiliary_seq2seq_task</a> 和<a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/classification_ifytek_with_similarity.py" target="_blank" rel="noopener">classification_ifytek_with_similarity</a></p><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>本文只是由于之前实验想到的尝试对label 做增强来实现模型增强的尝试，最后两组实验都没取得什么好的结果。</p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1><p>摄于翠湖湿地</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://xv44586.github.io/categories/NLP/"/>
    
    
      <category term="Classification" scheme="https://xv44586.github.io/tags/Classification/"/>
    
  </entry>
  
  <entry>
    <title>Knowledge Distillation (2) &amp;#58; 知识迁移</title>
    <link href="https://xv44586.github.io/2020/08/31/bert-01/"/>
    <id>https://xv44586.github.io/2020/08/31/bert-01/</id>
    <published>2020-08-31T15:14:55.000Z</published>
    <updated>2020-10-25T02:55:33.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#distilling-knowledge">Distilling Knowledge</a><ul><li><a href="#distilling-the-knowledge-in-a-neural-network">Distilling the Knowledge in a Neural Network</a><ul><li><a href="#distilling">Distilling</a></li></ul></li><li><a href="#distill-bert">Distill BERT</a></li><li><a href="#tinybert">TinyBERT</a><ul><li><a href="#you-dian">优点</a></li><li><a href="#que-dian">缺点</a></li></ul></li><li><a href="#distilbert">DistilBERT</a><ul><li><a href="#you-dian-1">优点</a></li></ul></li><li><a href="#mobilebert">MobileBERT</a><ul><li><a href="#you-dian-2">优点</a></li><li><a href="#que-dian-1">缺点</a></li></ul></li></ul></li><li><a href="#lun-wen-zong-jie">论文总结</a></li><li><a href="#xiang-fa">想法</a></li><li><a href="#shi-yan">实验</a><ul><li><a href="#teacher-to-student">Teacher-to-Student</a></li><li><a href="#student-to-student">student-to-student</a></li><li><a href="#normal-noise-training">normal-noise-training</a></li></ul></li><li><a href="#shi-yan-jie-guo">实验结果</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --></div><p>上篇讨论了<a href="https://xv44586.github.io/2020/08/31/bert-01/">bert-of-theseus</a>，算是一个开篇，本文继续讨论关于模型蒸馏（Distilling Knowledge）及关于BERT模型的知识蒸馏。<br>模型蒸馏的最重要的一个特点就是降低资源使用和加速模型推理速度，而小模型往往性能较低，本文总结一些如何通过蒸馏来使小模型具有更好的性能。</p><h1><span id="distilling-knowledge">Distilling Knowledge</span><a href="#distilling-knowledge" class="header-anchor"></a></h1><h2><span id="distilling-the-knowledge-in-a-neural-network">Distilling the Knowledge in a Neural Network</span><a href="#distilling-the-knowledge-in-a-neural-network" class="header-anchor"></a></h2><p>这篇是2015年Hinton发表的,也是我看到的最早提出Knowledge Distillation的<a href="http://arxiv.org/abs/1503.02531" target="_blank" rel="noopener">论文</a>。<br>在这篇论文中，Hinton指出one-hot 的label只指示了true label 的信息，但是没有给出negative label 之间、negative 与 true label之间<br>的相对关系，比如：比如现在的任务是给定一个词（比如：苹果），然后判断词对应的类别（电视/手机/水果/汽车），假如现在我们有两个样本：<br>（苹果，[0,0,1,0]）和 （小米，[0,1,0,0]), 而one-hot 形式的label并不能告诉我们，苹果中 label是水果的概率高出label是拖拉机的概率，<br>稍低于是手机的概率，而小米中label是电视的概率稍低于是手机的概率，但是同时要高于是汽车和水果的概率，这些相对关系在one-hot 形式的label中<br>是无法得到的，而这些信息非常重要，有了这些信息，我们可以更容易的学习任务。于是提出了Teacher-Student模式，<br>即用一个大的复杂的模型（也可以是ensemble后的）来先学习，然后得到label的相对关系（logits），然后将学习到的知识迁移到一个小模型（Student）。</p><h3><span id="distilling">Distilling</span><a href="#distilling" class="header-anchor"></a></h3><p>具体迁移过程是Student 在进行training 时，除了学习ground truth 外，还需要学习label 的probability（softmax output），但是不是直接学习<br>softmax output，而是学习<code>soften labels</code>，所谓soften labels 即经过<code>Temperature</code> 平滑后的 probability，具体形式：<br>$$<br>q_{i} = \frac{exp(z_{i}/T)}{\sum_{j}^{}exp(z_{j}/T)}<br>$$<br>其中T 越大，对应的probability 越平滑，如下图所示。而平滑probability 可以看作是对soften label的一种正则化手段。<br> <img src="/2020/08/31/bert-01/soften.png" alt></p><p>更直观的实验请查阅<a href="https://github.com/xv44586/Knowledge-Distillation-NLP/blob/master/Knowledge_Distillation_From_Scratch.ipynb" target="_blank" rel="noopener">Knowledge Distillation From Scratch</a></p><h2><span id="distill-bert">Distill BERT</span><a href="#distill-bert" class="header-anchor"></a></h2><p>看到的第一篇针对BERT 模型做蒸馏的是<a href="http://arxiv.org/abs/1903.12136" target="_blank" rel="noopener">Distilling Task-Specific Knowledge from BERT into Simple Neural Networks</a>,<br>在这篇论文中，作者延续Hinton 的思路在BERT 上做实验，首先用BERT-12 做Teacher，然后用一个单层Bi-LSTM 做Student，loss 上除了<br>ground truth 外，也选择了使用teacher 的logits，包括Temperature 平滑后的soften labels 的CrossEntropy和 logits 之间的MSE，<br>最后实验验证MSE效果优于CE。<br>此外，由于是从头开始训练Student，所以只用任务相关数据会严重样本不足，所以作者提出了三种NLP的任务无关的data augment策略：</p><ol><li><strong>mask：随机mask一部分token作为新样本，让teacher去生成对应logits ;</strong></li><li><strong>根据POS标签去替换，得到 ”What do pigs eat?” -&gt; “ How do pigs ear?”</strong></li><li><strong>n-gram采样：随机选取n-gram，n取[1-5]，丢弃其余部分。</strong></li></ol><p>在<a href="http://arxiv.org/abs/1503.02531" target="_blank" rel="noopener">Distilling the Knowledge in a Neural Network</a>中曾指出 logits 之间的CrossEntropy是可以看作<br>是MSE 的近似版本，不过这里作者的结论是MSE 更好，此外，由于Hinton 实验时是巨大数据量，所以不存在样本不足的情况，而普通实验时都会遇到<br>迁移时训练样本不足，需要做数据增强的问题。</p><h2><span id="tinybert">TinyBERT</span><a href="#tinybert" class="header-anchor"></a></h2><p>TinyBERT 出自<a href="http://arxiv.org/abs/1909.10351" target="_blank" rel="noopener">TinyBERT: Distilling BERT for Natural Language Understanding</a>,由于Transformer 结构<br>在NLP 任务中的强大能力，作者选择用与BERT 同结构的方式做Student，此外，为了提高KD后模型性能，做了更细致的工作：</p><ol><li><strong>Student选择一个更窄更浅的transformer;</strong></li><li><strong>将KD也分为两个阶段：pre-train 和 fine-tuning，并且在两个阶段上都进行KD;</strong></li><li><strong>使用了更多的loss：Embedding之间的MSE，Attention Matrix中的logits之间的MSE，Hidden state之间的MSE以及最后的分类层的CE;</strong></li><li><strong>为了提高下游任务fine-tuning后的性能，使用了近义词替换的策略进行数据增强.</strong></li></ol><h3><span id="you-dian">优点</span><a href="#you-dian" class="header-anchor"></a></h3><ol><li><strong>6层transformer基本达到了bert-12的性能，并且hidden size更小，实际是比bert-6更小的;</strong></li><li><strong>因为有pre-train KD，所以可以拿来当bert 一样直接在下游fine-tuning.</strong></li></ol><h3><span id="que-dian">缺点</span><a href="#que-dian" class="header-anchor"></a></h3><ol><li><strong>由于hidden size的不同，所以为了进行MSE，需要用一个参数矩阵W 来调节，这个参数只在训练时使用，训练完后丢弃，这个矩阵没有任何约束，觉得不优雅;</strong></li><li><strong>其次，student model的每一层都需要去学习teacher model的对应的block的输出，如何对不同的层如何设计更好的权重也是一个费力的事；</strong></li><li><strong>虽然student的结构也是transformer，但是由于hidden size 不同，没法使用teacher的预训练结果，但是我觉得这里其实可以用降维的方式用<br>teacher的预训练结果，可能不需要pretraining的阶段了也说不定。</strong></li></ol><h2><span id="distilbert">DistilBERT</span><a href="#distilbert" class="header-anchor"></a></h2><p>DistilBERT 出自<a href="http://arxiv.org/abs/1910.01108" target="_blank" rel="noopener">DistilBERT, a distilled version of BERT: smaller, faster, cheaper and lighter</a>,<br>论文中作者通过调查发现BERT 中的hidden size 的对计算效率的改变比hidden layer nums 的影响小，说白了就是让模型变矮比让模型变瘦效率更高，<br>所以作者使用了一个更矮的BERT来做Student 来迁移BERT 中的知识。由于DistilBERT 是一个与BERT 同结构只是层数更小，所以DistilBERT 可以用<br>BERT 的预训练的权重进行初始化，此外，DistilBERT 是一个与任务无关的模型，即与BERT 一样，可以对很多下游任务进行fine-tuning。<br>由于DistilBERT 与 BERT 的前几层一致，所以loss 的选择上就更多一些，作者选择了triple loss：<br>MLM loss + embedding cosin loss + soften labels cross entropy .s</p><h3><span id="you-dian">优点</span><a href="#you-dian" class="header-anchor"></a></h3><p>DistilBERT 做到了与BERT 一样，完全与任务无关，不需要添加额外的Distillation 阶段（添加后结果会更好)。</p><h2><span id="mobilebert">MobileBERT</span><a href="#mobilebert" class="header-anchor"></a></h2><p>MobileBERT 出自<a href="http://arxiv.org/abs/2004.02984" target="_blank" rel="noopener">MobileBERT: a Compact Task-Agnostic BERT for Resource-Limited Devices</a>,<br>作者同样采用一个transformer 作为基本结构，但作者认为深度很重要，宽度较小对模型损坏较小，所以整体架构是保持模型深度不变，<br>通过一个矩阵来改变feature size，即bottleneck，在通过在block的前后插入两个bottleneck，来scale feature size。由于<br>MobileBERT太窄太深，所以不好训练，作者提出新的方式，通过一个同深但是更宽的同架构的模型来训练 作为teacher，然后用MobileBERT迁移。<br>loss 设计上主要包括三部分：feature map之间的MSE，Attention logits之间的KL，以及pre-training MLM + pre-training-NSP + pre-training-KD<br>训练策略上，有三种方式：</p><ol><li><strong>将KD作为附加预训练的附加任务，即一起训练；</strong></li><li><strong>分层训练，每次训练一层，同时冻结之前的层；</strong></li><li><strong>分开训练，首先训练迁移，然后单独进行pre-training.</strong></li></ol><p>此外，为了提高推理速度，将gelu 替换为更快的 relu ，LayerNormalization 替换为 更简单的NoNorm，也做了量化的实验。</p><h3><span id="you-dian">优点</span><a href="#you-dian" class="header-anchor"></a></h3><ol><li><strong>首先mobileBERT容量更小，推理更快，与任务无关，可以当bert来直接在下游fine-tuning，而之前的KD大多数时候需要与任务绑定并使用数据<br>增强，才能达到不错的性能；</strong></li><li><strong>论文实验非常详实，包括如何选择inter-block size, intra-block size, 不同训练策略如何影响等;</strong></li><li><strong>训练策略上，除了之前的一起训练完，实验了两种新的训练方式，而最终的一层一层的训练与skip connection 有异曲同工的作用：每层都学一小部分<br>内容，从而降低学习的难度；</strong></li><li><strong>替换了gelu 和 LayerNormalization,进一步提速.</strong></li></ol><h3><span id="que-dian">缺点</span><a href="#que-dian" class="header-anchor"></a></h3><ol><li>要训练一个IBBERT作为teacher，而这个模型容量与BERT-Large差不多，增加了训练难度.</li></ol><h1><span id="lun-wen-zong-jie">论文总结</span><a href="#lun-wen-zong-jie" class="header-anchor"></a></h1><p>以上论文的迁移过程其实可以总结为两类：</p><ol><li><strong>soft label迁移，即主要迁移Teacher 模型最后分类层的logits 及相应的soft label；</strong></li><li><strong>feature迁移，即除了最后分类层外，还迁移Teacher 模型中的output/attention/embedding等特征。</strong></li></ol><p>Student 的选择上，除了自定义外，还可以选择跟Teacher 同结构，而为了降低参数量，可以选择将模型变矮/变窄/减小hidden size 等方式。<br>而为了蒸馏后的模型能更加的general，适应更多的task，就需要迁移更多的信息，设计上也越复杂。</p><h1><span id="xiang-fa">想法</span><a href="#xiang-fa" class="header-anchor"></a></h1><p>实际工作上，大多数时候我们都是需要一个task 来做模型，而以上论文中告诉我们，迁移的信息越多，Student 的性能越好。而针对具体task ，我觉得<br>比较简洁有效的一种方式是采用更矮的Teacher 来作为Student ，这样可以直接将Teacher 中的前几层的信息完全迁移过来，然后在object 上，<br>加入迁移Teacher 在train data 上的logits ，这样就可以比较有效的进行蒸馏了。<br>除此之外，让我们换个角度看看为什么logits 能增强Student 模型的性能呢？除了迁移的角度外，其实logits 提供了label<br>更多的信息（不同类别的相对关系），而这个额外信息只要优于随机分布，就能对模型提供更多的约束信息，从而增强模型性能，即当前的模型可以看<br>作是分别拟合ground truth 和 logits的两个模型的<code>ensemble</code>，只不过是两个模型共享参数。<br>上面我们提到只要logits 优于随机，对Student 模型来说就会有所提升，那logits 由谁产生的其实并不重要。所以，我们除了可以用Teacher 产生的<br>logits来增强Student 模型外，我们还可以增强Teacher 模型，或者直接用Student 先学习一下，产生logits，再用Student 去迁移上次产生的logits。<br>想到这里，我不禁的有个大胆的想法：<code>既然我可以一边生成logits， 一边学习logits，那我不是可以持续这个过程，直到模型完全拟合train data，<br>生成的logits退化为one-hot，那此时的模型是不是能得到一个非常大的提升呢？</code></p><h1><span id="shi-yan">实验</span><a href="#shi-yan" class="header-anchor"></a></h1><p>实验的基本设置是用12层bert 作为Teacher model ，用3层bert 作为Student model 。soften labels 采用Temperature 平滑后的结果，此外，<br>Student model 除了学习 soften labels 的外，也需要学习ground truth。</p><h2><span id="teacher-to-student">Teacher-to-Student</span><a href="#teacher-to-student" class="header-anchor"></a></h2><p>Teacher model 在train data 上训练，然后在train data 上生成对应的soften labels，Student model 学习ground truth 和 soften labels。 </p><h2><span id="student-to-student">student-to-student</span><a href="#student-to-student" class="header-anchor"></a></h2><p>既然soften labels 是一种对labels 的一种平滑估计，那我们可以用任何方式去估计他，所以这里我们就用student 去做一个估计：<br>student model 在train data 上进行训练，然后在train data 上生成对应的soften labels ，将 student model 利用bert 预训练结果重新初始化，<br>然后去学习ground truth 和 soften labels.</p><h2><span id="normal-noise-training">normal-noise-training</span><a href="#normal-noise-training" class="header-anchor"></a></h2><p>既然是对labels 的一个估计，那假如给一个随机的估计，只要保证生成的logits 中true label 对应的值最大，就能对Student 模型进行一定程度的提升：<br>直接在train label 上添加一个normal noise ，然后重新进行平滑后归一，作为soften labels让student model 去学习。</p><h1><span id="shi-yan-jie-guo">实验结果</span><a href="#shi-yan-jie-guo" class="header-anchor"></a></h1><p>$$<br>\begin{array}{c|c|c}<br>\hline \\<br>\text{teacher standalone} &amp; \text{student standalone} &amp; \text{teacher-to-student} &amp; \text{teacher-to-teacher} &amp; \text{student-to-student} &amp; \text{normal-noise-student}\\<br>\hline \\<br>60.21\% &amp; 58.14\% &amp; 60.14\% &amp; 60.14\% &amp; 61.07\% &amp; 59.5\%<br>\end{array}<br>$$</p><p>从结果中可以看到：</p><ol><li><strong>优于随机的logits 对Student 模型有一定的提升，估计越准确，提升越高；</strong></li><li><strong>越大的模型性能越好;</strong><br>3.<strong>迭代进行logits 的生成与训练不能进一步提高模型性能，原因主要是新的logits 分布相比之前的对模型的提升非常小，此外这个分布也比较容易拟<br>合，所以无法进一步提升。</strong></li></ol><p>完整实验代码地址<a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/distilling_knowledge_bert.py" target="_blank" rel="noopener">distilling_knowledge_bert</a></p><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>本文主要针对目前针对BERT 的知识蒸馏进行了总结，并提出了针对具体任务时可行的简洁方案，同时在新的视角下探讨了知识蒸馏有效的一些原因，<br>并通过实验进行了验证，发表顺序上上篇<a href="https://xv44586.github.io/2020/08/09/bert-of-theseus/">bert-of-theseus</a> 更晚一些，有兴趣的可以再去看一下上一篇。</p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1><p>芝麻街</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://xv44586.github.io/categories/NLP/"/>
    
    
      <category term="BERT" scheme="https://xv44586.github.io/tags/BERT/"/>
    
      <category term="Distillation" scheme="https://xv44586.github.io/tags/Distillation/"/>
    
  </entry>
  
  <entry>
    <title>模型增强（1）&amp;#58; 利用NLG 增强QA 任务性能</title>
    <link href="https://xv44586.github.io/2020/08/22/qa-augmentation/"/>
    <id>https://xv44586.github.io/2020/08/22/qa-augmentation/</id>
    <published>2020-08-22T01:38:13.000Z</published>
    <updated>2020-10-25T02:55:33.062Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#bei-jing">背景</a></li><li><a href="#unilm">UniLM</a></li><li><a href="#shu-ju-zeng-qiang">数据增强</a></li><li><a href="#shi-yan">实验</a><ul><li><a href="#wen-ti-sheng-cheng">问题生成</a></li><li><a href="#wen-ti-da-an-dui-sheng-cheng">问题答案对生成</a></li></ul></li><li><a href="#zong-jie">总结</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --></div><h1><span id="bei-jing">背景</span><a href="#bei-jing" class="header-anchor"></a></h1><p>上周打算把UniLM在<a href="https://github.com/xv44586/toolkit4nlp" target="_blank" rel="noopener">toolkit4nlp</a>的基础上实现一下，又刷了一遍<a href="https://arxiv.org/pdf/1905.03197.pdf" target="_blank" rel="noopener">论文</a>,发现作者提到用UniLM做问题生成，来增强QA任务的性能，觉得很有意思，所以想尝试一下。</p><h1><span id="unilm">UniLM</span><a href="#unilm" class="header-anchor"></a></h1><p>因为这篇 UniLM 是主角，所以简单介绍一下该模型。该模型是通过灵活使用 attention mask ，将 NLG 与 NLU 任务统一在来一起，所以叫 unified LM，<br>他的做法是将 left-to-right/right-to-left/masked lm/seq2seq lm/放在一个框架里训练，从而让模型兼具 NLU 与 NLG 的能力。<br><img src="/2020/08/22/qa-augmentation/lm.png" alt><br>而为了达到这个训练，只需要在 bert 的基础上根据不同的 lm 调整 attention mask 即可。所以利用 bert 做 NLG 时，只需要调整 attention mask<br>为 seq2seq lm 对应mask即可。</p><h1><span id="shu-ju-zeng-qiang">数据增强</span><a href="#shu-ju-zeng-qiang" class="header-anchor"></a></h1><p>通常增强都是同义词/近义词替换，subsequence的随机删除/重复/互换等，我之前在做百度比赛时尝试过随机删除和随机两个片段互换位置，提升不是<br>非常大而论文里大问题生成带来大提升还是相当大的：<br><img src="/2020/08/22/qa-augmentation/table9.png" alt><br>仔细想一下，由于attention机制，互换只是改变了position embedding部分内容，而这部分的互换对模型的影响是很弱的；随机删除可能会破坏语义，<br>所以增加模型robust的同时可能会降低模型性能。而问题生成，则可以看作是同义词/近义词替换的句子级别替换，所以理论上能带来不错的提升。<br>从对抗的角度来看，生成的问题在语义上与原问题基本一致，这也正好符合<code>输入的微小改变</code>，从而让模型在这种带有微小扰动的前提下仍然能很好的预测。</p><h1><span id="shi-yan">实验</span><a href="#shi-yan" class="header-anchor"></a></h1><p>既然UniLM具有很强的NLG能力能力，那就有很多不同的玩法。首先，可以训练一个模型，来针对 context 和 answer 生成对应的问题，来对问题进行<br><code>“换个问法”</code>，其次，既然可以对问题<cdoe>“换个问法”,自然也可以<code>“换个问题”</code>,也就是根据 context 生成新的问题<br>和答案。另外，由于是扩增训练数据，所以有一个技巧是做生成是将 train data 与 dev data 互换，不过由于我用的是百度比赛数据，dev data 太少，<br>所以我是 train + dev。</cdoe></p><h2><span id="wen-ti-sheng-cheng">问题生成</span><a href="#wen-ti-sheng-cheng" class="header-anchor"></a></h2><p>问题生成时，就是将 context 与 answer 拼接，然后生成对应的question。具体样本形如：<code> [CLS] answer + context [SEP] question [SEP]</code> .<br>模型直接用bert base权重按UniLM的seq2seq方式来构建，可以看到效果还是很不错的，比如：</p><blockquote><br>context：报雅思或者托付培训班,一般情况下要900元左右。 雅思和托福考试可以自学: 一、基础知识准备:单词、基本语法、长难句分析; 二、板块训练:听说读写,四个板块; 三、合理备考计划,可以参见中国上别人经验结合自己的自身条件; 四、效果强化跟踪,使用合理的备考软件或者是自测题目随时跟踪自己的学习状态<br>question：雅思班价格<br>answer: [‘900元’, ‘900元左右’]<br>generate question: 雅思班报名多少钱<br></blockquote><blockquote>context：USB电压有5伏 USB一般4根线, 中间两根是数据线, 左右各为 +- 线 只要不短路是不会烧主板该插口的 ,我想你应该这样做,手机的线的一端直接插入手提电脑,另一头剪掉头子,从线中分离出四根线, 用万用表测出(红色+和其它色如黑-)剩下两根用胶布包扎(不用)然后 在这两根线上(正电极中最好串一50到100欧电阻)后接入一支高亮度发光二极管就成功了.<br>question：usb线电压<br>answer: [‘5伏’]<br>generate question: usb线电压 </blockquote><p>解码时，有两种选择：随机抽样与 beam search 。随机抽样可以增加问题的多样性，并且可以生成多个问题；beam search近似最优，得到一个最优的<br>问题。由于我们是使用 train data 训练模型，在对 train data 生成新的问题时，beam search 将可能产生很多一摸一样的问题，这样将降低新增<br>数据的量；而随机抽样能产生很多新的问题，但可能新生成的问题与答案并不配套，还需要一些后处理之后才能真正拿来用。这里两种方式都拿来做实验，<br>并对生成的问题做一个简单的过滤：新生成的问题与原问题中有70%以上的字是重合的。<br>$$<br>\begin{array}{c|c|c}<br>\hline \\<br>\text{base line} &amp; \text{beam search} &amp; \text{random sample}\\<br>\hline \\<br>80.39\% &amp; 81.0\% &amp; 79.8\%<br>\end{array}<br>$$</p><p>random sample的样本经过了很多次过滤之后才能基本达到baseline的效果，所以生成的问题如果”问非所答”，对最终的效果反而是不好的，这也符合预期。</p><h2><span id="wen-ti-da-an-dui-sheng-cheng">问题答案对生成</span><a href="#wen-ti-da-an-dui-sheng-cheng" class="header-anchor"></a></h2><p>问题答案对生成时，由于答案是在 context 内的，相对问题生成简单一些，所以我们先生成答案，再根据 context 和生成的 answer 来生成对应的<br>question。不过为了让问题答案对更丰富多样，解码答案时我们采用随机抽样，而生成问题时，为了让问题尽量准确，我们采用 beam search。<br>样本形如 <code>[CLS]context[SEP]answer[SEP][question][SEP]</code>，生成的效果如下：</p><p><blockquote><br>context：您好，孕妇整个孕期体重增加12.5公斤左右，在增加的这12.5公斤中，胎儿的体重占3公斤左右，胎盘和羊水约是2公斤左右。在孕早期（怀孕3个月以内）增加2公斤，中期（怀孕3－6个月）以及末期（怀孕7－9个月）各增加5公斤左右。所以怀孕6个月体重增加7公斤左右比较正常。希望我的回答对你有所帮助。<br>question：孕妇6个月体重增加多少<br>answer: 7公斤左右<br>generate question: 孕妇6个月体重增加多少<br>generate answer: 12.5公斤左右<br></blockquote><br>不过也由于train data 参与训练，所以很多生成的问题答案对与原始问题答案对一致，如果有更多的外部数据，可以利用外部数据来训练。<br>$$<br>\begin{array}{c|c|c|c}<br>\hline \\<br>\text{base line} &amp; \text{beam search} &amp; \text{random sample} &amp; \text{question answer generation}\\<br>\hline \\<br>80.39\% &amp; 81.0\% &amp; 79.8\% &amp; 81.76\% \\<br>\hline<br>\end{array}<br>$$</p><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>通过生成新的问题与新的问题答案对能在一定程度上提高qa 任务的性能，在生成问题时，用beam search 得到的新问题虽然量少但由于更准确，所以<br>能带来一定的提升；用随机采样生成的问题会有部分与答案无关的或者语义有点不通顺的问题，所以可能反而会导致性能降低；问题答案对的生成时，<br>先生成相对简单的回答再生成对应问题，能对性能带来不错的提升，在做qa相关任务时，可以尝试使用一下。<br>实验代码：<br><a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/qa_baseline.py" target="_blank" rel="noopener">qa_baseline</a><br><a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/qa_question_generation_seq2seq.py" target="_blank" rel="noopener">qa_question_generation_seq2seq</a><br><a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/qa_question_answer_generation_seq2seq.py" target="_blank" rel="noopener">qa_question_answer_generation_seq2seq</a></p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1><p>看瓜的怒气小猫</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://xv44586.github.io/categories/NLP/"/>
    
    
      <category term="QA" scheme="https://xv44586.github.io/tags/QA/"/>
    
      <category term="NLG" scheme="https://xv44586.github.io/tags/NLG/"/>
    
      <category term="UniLM" scheme="https://xv44586.github.io/tags/UniLM/"/>
    
  </entry>
  
  <entry>
    <title>Knowledge Distillation (1) &amp;#58; 模块替换之bert-of-theseus-下篇</title>
    <link href="https://xv44586.github.io/2020/08/19/bert-of-theseus-2/"/>
    <id>https://xv44586.github.io/2020/08/19/bert-of-theseus-2/</id>
    <published>2020-08-19T14:12:28.000Z</published>
    <updated>2020-11-11T15:06:50.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#fu-xian-shi-de-wen-ti">复现时的问题</a><ul><li><a href="#si-kao-1-wei-shi-me-shi-xiao">思考1：为什么失效</a></li><li><a href="#si-kao-er-bert-of-theseus-you-xiao-de-ben-zhi-shi-shi-me">思考二 ：bert-of–theseus有效的本质是什么</a></li><li><a href="#shi-yan-1">实验1</a></li><li><a href="#si-kao-san-zhi-jie-zai-predecessor-shang-chou-successor-xing-bu-xing">思考三：直接在predecessor 上抽successor行不行？</a></li><li><a href="#shi-yan-2">实验2</a></li></ul></li><li><a href="#zong-jie">总结</a></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --></div><p>上一篇<a href="https://xv44586.github.io/2020/08/09/bert-of-theseus/">模块替换之bert-of-theseus-上篇</a>中介绍了bert-of-theseus论文的主要思路，并贴了两组实验的结论，这篇是对上篇的后续一些思考与实验。</p><h1><span id="fu-xian-shi-de-wen-ti">复现时的问题</span><a href="#fu-xian-shi-de-wen-ti" class="header-anchor"></a></h1><p>在复现时，遇到最大的问题就是结果不稳定。首先每次训练predecessor时，其最优结果就会有上下1个点左右的波动，而因为theseus 中引入了随机数<br>来概率替换对应block，所以结果上一言难尽，有时能比12层bert低0.6个点, 有时只能达到直接3层fine tuning 的效果，于是我做了些观察与思考。</p><h2><span id="si-kao-1-wei-shi-me-shi-xiao">思考1：为什么失效</span><a href="#si-kao-1-wei-shi-me-shi-xiao" class="header-anchor"></a></h2><p>在训练theseus model时，其中抽出的successor在每个epoch结束后在验证集上的结果有时会很高，基本到达只比三层fine-tuning低6个点，有时又很<br>低，基本不到0.1%, 第一种明显是successor在theseus中训练太多，以至于接近直接fine tuning，而另一种情况下可能是successor训练不充足，<br>也可能是替换次数太少导致没有被训练，而且大多数情况下successor的验证集上都是不到0.1%。<br>为了验证第二种情况下是否是未替换导致successor在做fine tuning，我将successor进行单独fine tuning后,将得到的classifier 拼回predecessor，<br>发现此时在验证集上d结果只下降了2个点，所以此时大概率是替换次数过少，基本没有训练到successor，所以导致结果不好，而这里开始我以为是我<br>实现问题，后来来来回回检查了一周，也没发现问题，于是我就想换一种更稳定的方式。</p><h2><span id="si-kao-er-bert-of-theseus-you-xiao-de-ben-zhi-shi-shi-me">思考二 ：bert-of–theseus有效的本质是什么</span><a href="#si-kao-er-bert-of-theseus-you-xiao-de-ben-zhi-shi-shi-me" class="header-anchor"></a></h2><p>熟悉bert的同学肯定对warm up不陌生，而warm up之所以有效，我认为比较重要的一点是如果在最初的steps中，模型提前拟合了样本，进入了一个局部<br>最优区域，后期无论你怎么迭代他都跳不出来，而由已经<code>fine tuned predecessor</code>带着一起再进行训练，也和warm up有些相似，即用小的<br>步子带着你朝着更优的方向走几步，跳出来，让你有进入更好的局部最优点的可能，此外，概率替换的思路也与<code>Dropout</code>有几分相似，让successor<br>有一定的几率参与训练，从而让successor在缺少predecessor的情况下也有一定的robust。<br><a href="https://spaces.ac.cn/archives/7575" target="_blank" rel="noopener">苏剑林的博客</a>里也提到了替换的数学形式：<br>$$<br>\begin{equation}\begin{aligned}<br>&amp;\varepsilon^{(l)}\sim U(\{0, 1\})\\<br>&amp;x^{(l)} = x_p^{(l)} \times \varepsilon^{(l)} + x_s^{(l)} \times \left(1 - \varepsilon^{(l)}\right)\\<br>&amp;x_p^{(l+1)} = F_p^{(l+1)}\left(x^{(l)}\right)\\<br>&amp;x_s^{(l+1)} = F_s^{(l+1)}\left(x^{(l)}\right)<br>\end{aligned}\end{equation}<br>$$<br>同时，他也提到$\epsilon$能否不取非0即1，那既然我们是想让successor在task方向上warm up一下，那直接相加，即此时 $\epsilon = k$,<br>k是常数也是可以的。此时只要调节k 就能避免successor训练不充分或太充分的情况了，模型也就稳定了，可以满足我们的要求了。</p><h2><span id="shi-yan-1">实验1</span><a href="#shi-yan-1" class="header-anchor"></a></h2><p>实验代码其实比较容易修改，只需将BinaryRandomChoice 层替换为相加即可。具体代码在<a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/classification_ifytek_bert_of_theseus.py" target="_blank" rel="noopener">classification_ifytek_bert_of_theseus</a><br>中可以看到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProportionalAdd</span><span class="params">(Layer)</span>:</span></span><br><span class="line">    <span class="string">"""将两层的结果乘比例后相加，output = (input_1 * proportion + input_2 * (1 - proportion)) / 2</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, proportion=<span class="number">0.5</span>, **kwargs)</span>:</span></span><br><span class="line">        super(ProportionalAdd, self).__init__(**kwargs)</span><br><span class="line">        self.supports_masking = <span class="literal">True</span></span><br><span class="line">        self.proportion = proportion</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_mask</span><span class="params">(self, inputs, mask=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> mask[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        source, target = inputs</span><br><span class="line">        source = source * self.proportion</span><br><span class="line">        target = target * (<span class="number">1</span> - self.proportion)</span><br><span class="line">        output = (source + target)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> K.in_train_phase(output, target)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_output_shape</span><span class="params">(self, input_shape)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> input_shape[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>文本分类：CLUE的iflytek数据集</p><p>$$<br>\begin{array}{c|c|c}<br>\hline<br>&amp; \text{直接微调} &amp; \text{BERT-of-Theseus}\\<br>\hline<br>\begin{array}{c}\text{层数} \\ \\text{效果}\end{array} &amp; \begin{array}{ccc}\text{完整12层} &amp; \text{前6层} &amp; \text{前3层}<br>\\ 60.11\% &amp; 58.99\%  &amp; 57.96\%\end{array} &amp; \begin{array}{cc}\text{6层} &amp; \text{3层} \\ 59.7\%  &amp; 59.5\% \end{array}\\<br>\hline<br>\end{array}<br>$$</p><p>结果上看确实更稳定了，也更好一点点了，基本比predecessor低<code>0.5%~1%</code> .</p><h2><span id="si-kao-san-zhi-jie-zai-predecessor-shang-chou-successor-xing-bu-xing">思考三：直接在predecessor 上抽successor行不行？</span><a href="#si-kao-san-zhi-jie-zai-predecessor-shang-chou-successor-xing-bu-xing" class="header-anchor"></a></h2><p>既然我们说bert-of-theseus有效的原因是在task 的方向进行了warm up，那predecessor已经在task上fine tuned了，能不能<code>直接抽取某几<br>层作为successor来直接fine tuning?</code>此外，之前我们也说了，predecessor与successor的classifer差距很小，那我们能不能改变successor<br>的classifer的学习率，让他进一步学习，来弥补一部分前三层无法拟合的分布呢？</p><h2><span id="shi-yan-2">实验2</span><a href="#shi-yan-2" class="header-anchor"></a></h2><p>具体实验代码<a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/two_stage_fine_tuning.py" target="_blank" rel="noopener">two-stage-fine-tuning</a><br>实验时尝试了<code>随机初始化classifier/predecessor classifier初始化classifier/ 放大classifier lr</code>组合策略，最后的结果就不贴了，基本都没有<br>超过3层bert fine tuning的效果。</p><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor"></a></h1><p>尝试分析了bert-of-theseus复现中的问题，并尝试了一些修复方案，同时，实验测试了theseus model的必要性，最后结论是binary random choice<br>策略不如 proportion add 策略稳定，同时，theseus是必须的。</p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1><p><a href="https://github.com/JetRunner/BERT-of-Theseus" target="_blank" rel="noopener">论文原作者配图</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://xv44586.github.io/categories/NLP/"/>
    
    
      <category term="BERT" scheme="https://xv44586.github.io/tags/BERT/"/>
    
      <category term="Distillation" scheme="https://xv44586.github.io/tags/Distillation/"/>
    
  </entry>
  
  <entry>
    <title>Knowledge Distillation (1) &amp;#58; 模块替换之bert-of-theseus-上篇</title>
    <link href="https://xv44586.github.io/2020/08/09/bert-of-theseus/"/>
    <id>https://xv44586.github.io/2020/08/09/bert-of-theseus/</id>
    <published>2020-08-09T13:26:26.000Z</published>
    <updated>2020-10-25T02:55:33.066Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="toc"><!-- toc --><ul><li><a href="#mo-xing-ya-suo">模型压缩</a><ul><li><a href="#jian-zhi">剪枝</a></li><li><a href="#liang-hua">量化</a></li><li><a href="#zhi-shi-zheng-liu">知识蒸馏</a></li><li><a href="#quan-chong-gong-xiang">权重共享</a></li><li><a href="#quan-chong-fen-jie">权重分解</a></li><li><a href="#mo-xing-ya-suo-de-bi-yao-xing">模型压缩的必要性</a></li><li><a href="#bert-of-theseus">Bert of theseus</a></li><li><a href="#ju-ti-liu-cheng">具体流程</a></li><li><a href="#shi-yan-xiao-guo">实验效果</a></li></ul></li><li><a href="#guan-yu-tou-tu">关于头图</a></li></ul><!-- tocstop --></div><blockquote>如果忒修斯的船上的木头被逐渐替换，直到所有的木头都不是原来的木头，那这艘船还是原来的那艘船吗？<br><br>-普鲁塔克</blockquote><p>最近遇到一个需要对算法加速的场景，了解到了一个比较简洁实用的方法：<a href="https://arxiv.org/abs/2002.02925" target="_blank" rel="noopener">Bert-of-theseus</a>,<br>了解了原理后参考代码实验后，验证了其有效性，所以总结一下。</p><h1><span id="mo-xing-ya-suo">模型压缩</span><a href="#mo-xing-ya-suo" class="header-anchor"></a></h1><p>模型在设计之初都是过参数化的，这是因为模型的参数量与复杂度代表着模型的容量与学习能力，但当我们实际使用时，我们需要更好的部署他（低资源），更快的响应（快速推理），常常需要进行模型压缩。<br>模型压缩就是<code>简化大的模型，得到推理快资源占用低的小模型</code>，而想”即要马而跑又不用吃草”通常是很难的，所以压缩后的模型常常也会有不同程度的牺牲，如模型性能下降。<br>此外，模型压缩是作用在推理阶段，带来的常常是训练时间的增加。<br>模型压缩又分为两种方式：一种是<code>剪枝(Pruning)</code>与<code>量化(Quantization)</code>,一种是<code>知识蒸馏(Knowledge Distillation)</code>,<br>还有一种是<code>权重共享（Sharing）与因数分解（Factorization）</code>。该部分内容推荐一篇博客：<a href="http://mitchgordon.me/machine/learning/2019/11/18/all-the-ways-to-compress-BERT.html" target="_blank" rel="noopener">All The Ways You Can Compress BERT</a></p><h2><span id="jian-zhi">剪枝</span><a href="#jian-zhi" class="header-anchor"></a></h2><p>剪枝技术是通过将大模型中一些”不重要”的连接剪断，得到一个”稀疏”结构的模型。剪枝又分为”结构性剪枝”与”非结构性剪枝”.剪枝可以作用在权重粒度，<br>也可以作用在attention heads / layer粒度上。不过剪枝技术感觉会逐步被<cdoe>NAS（Neural Architecture Search）取。</cdoe></p><h2><span id="liang-hua">量化</span><a href="#liang-hua" class="header-anchor"></a></h2><p>量化不改变模型的网络结构，而是改变模型的参数的数据格式，通常模型在建立与训练时使用的是 float32 格式的，量化就是将格式转换为 <code>low-bit</code>, 如 float16 甚至二值化，如此即提速又省显存。</p><h2><span id="zhi-shi-zheng-liu">知识蒸馏</span><a href="#zhi-shi-zheng-liu" class="header-anchor"></a></h2><p>知识蒸馏是训练一个小模型(student)来学习大模型(teacher)，由于大模型是之前已经fine-tuning的，所以此时学习的目标已经转换为对应的logit而<br>不再是one-hot编码了，所以student有可能比teacher的性能更好。这样即小又准的模型实在太好了。不过为了达到这样的效果，通常设计小模型时不<br>光要学习大模型的输出，还要学习各个中间层结果，相关矩阵等，这就需要仔细设计模型的结构与loss及loss融合方案了。一种简单的方法是只学习大模型的logit，这与对label做embedding有点类似，不过我没做过实验还。</p><h2><span id="quan-chong-gong-xiang">权重共享</span><a href="#quan-chong-gong-xiang" class="header-anchor"></a></h2><p>将部分权重在多个层中共享以达到压缩模型的效果，如ALBERT中共享self-attention中的参数</p><h2><span id="quan-chong-fen-jie">权重分解</span><a href="#quan-chong-fen-jie" class="header-anchor"></a></h2><p>将权重矩阵进行因数分解，形成两个低秩的矩阵相乘的形式，从而降低计算量</p><h2><span id="mo-xing-ya-suo-de-bi-yao-xing">模型压缩的必要性</span><a href="#mo-xing-ya-suo-de-bi-yao-xing" class="header-anchor"></a></h2><p>看了上面模型压缩的方法，每一个都有种”脱裤子放屁”的感觉，与其训练一个大模型，再费力把它变小，为何不直接开始就弄个小的呢？<br>首先，模型在设计之初是都是会或多或少的过参数化，因为模型的参数量与复杂度代表着模型的容量与学习能力；<br>其次，开始就用一个小模型，那这个小模型也是需要设计的，不能随便拿来一个，而设计一个性能高参数规模小的小模型难度是非常大的，往往是模型小了性能也低了；<br>第三点，大模型压缩后与小模型虽然参数规模相当，但是对应的模型空间并不相同<br>此外，为了更好的部署，如手机或FPGA等，得到精度更高模型更小(distillation)或者利用硬件加速(low-bit)，模型压缩都是值得试一试的手段。<br>更详细的讨论，可以参考<a href="https://www.zhihu.com/question/303922732" target="_blank" rel="noopener">为什么要压缩模型，而不直接训练一个小的CNN</a></p><h2><span id="bert-of-theseus">Bert of theseus</span><a href="#bert-of-theseus" class="header-anchor"></a></h2><p>Bert of theseus 方法属于上面提到的知识蒸馏，知识蒸馏中我们提到，在蒸馏时，我们不光要学习teacher的输出，对中间层我们也希望他们直接尽量相似，<br>那想象一个这种状态对应对理想情况：<code>中间层的结果一致，最终的结果一致</code>,既然我们的期望中间结果一致，那也就意味着两者可以互相替换。<br>正如开头提到的忒修斯之船一样。所以核心思想是：<br><code>与其设计复杂的loss来让中间层结果相似不如直接用小模型替换大模型来训练</code><br>通过复杂loss来达到与中间层结果相似可以看作是一种整体渐进式的逼近，让小模型一点点去学习，而直接替换可以看作是一种简单粗暴的方式，<br>但是他不需要设计各种loss，优化目标也是同一个，就只有一个下游任务相关的loss，突出一个<code>简洁</code>。<br>这就好比高中上学一样，即使花高价也要让孩子去一所好高中，因为学校的”氛围”能让孩子的学习成绩进步，其实是因为周围的孩子带着一起学，<br>弱鸡也能学的比平时更多一点。bert-of-theseus也是类似的道理，跟着大佬（teacher）总比单独fine-tuning效果好。</p><h2><span id="ju-ti-liu-cheng">具体流程</span><a href="#ju-ti-liu-cheng" class="header-anchor"></a></h2><p>如果直接将小模型替换大模型，那其实是在对小模型进行微调，与大模型就脱离了，也达不到对应的效果，所以作者采用了一种概率替换的方式。<br>首先呢，想象我们现在已经训练好了一个6层的BERT，我们成为<code>Predecessor（前辈）</code>, 而我们需要训练一个三层的bert，<br>他的结果近似12层BERT的效果，我们成为<code>Successor(传承者)</code>,那 bert-of-theseus的模型结构如<a href="https://spaces.ac.cn/archives/7575" target="_blank" rel="noopener">下图</a>所示：</p><p><img src="/2020/08/09/bert-of-theseus/bert-of-theseus.png" alt="bert-of-theseus"></p><p>在bert-of-theseus中，首先固定predecessor的权重，然后将6层的Bert分为3个block，每个block与successor的一层对应，训练过程分为两个stage：<br>首先用successor中的层概率替换predecessor中对应的block，在下游任务中直接fine-tuning（只训练successor），<br>然后将successor从bert-of-theseus中分离出来，单独在下游任务中进行fine-tuning，直到指标不再上升。<br>所谓替换，就是输出的替换，在进入下一层前在predecessor和successor的输出中二选一。<br>替换概率作者也给出了两种方式，一种是固定 0.5,一种是线性从0-1,如下图所示：<br><img src="/2020/08/09/bert-of-theseus/figure2.png" alt></p><h2><span id="shi-yan-xiao-guo">实验效果</span><a href="#shi-yan-xiao-guo" class="header-anchor"></a></h2><p>实验代码主要参考<a href="https://github.com/bojone/bert-of-theseus" target="_blank" rel="noopener">bert-of-theseus</a>, 实验主要做了三组，一组文本分类两组ner-crf，结果如下：</p><p>文本分类：CLUE的iflytek数据集</p><p>$$<br>\begin{array}{c|c|c}<br>\hline<br>&amp; \text{直接微调} &amp; \text{BERT-of-Theseus}\\<br>\hline<br>\begin{array}{c}\text{层数} \\ \\text{效果}\end{array} &amp; \begin{array}{ccc}\text{完整12层} &amp; \text{前6层} &amp; \text{前3层}<br>\\ 60.11\% &amp; 58.99\%  &amp; 57.96\%\end{array} &amp; \begin{array}{cc}\text{6层} &amp; \text{3层} \\ 59.6\%  &amp; 59.3\% \end{array}\\<br>\hline<br>\end{array}<br>$$</p><p>ner-crf: 公司数据<br>$$<br>\begin{array}{c|c|c}<br>\hline<br>&amp; \text{直接微调} &amp; \text{BERT-of-Theseus}\\<br>\hline<br>\begin{array}{c}\text{层数} \\ \\text{效果}\end{array} &amp; \begin{array}{ccc}\text{完整12层} &amp; \text{前6层} &amp; \text{前3层}<br>\\ 97.5\% &amp; 97.0\%  &amp; 96.1\%\end{array} &amp; \begin{array}{cc}\text{6层} &amp; \text{3层} \\ 97.3\%  &amp; 96.6\% \end{array}\\<br>\hline<br>\end{array}<br>$$</p><p>可以看到，相比直接那前几层微调，bert-of-theseus的效果确实更好，此外，我还尝试了线性策略的替换概率，效果上差别不大。<br>实验代码：<a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/classification_ifytek_bert_of_theseus.py" target="_blank" rel="noopener">classification_ifytek_bert_of_theseus</a><br><a href="https://github.com/xv44586/toolkit4nlp/blob/master/examples/sequence_labeling_ner_bert_of_theseus.py" target="_blank" rel="noopener">sequence_labeling_ner_bert_of_theseus</a></p><h1><span id="guan-yu-tou-tu">关于头图</span><a href="#guan-yu-tou-tu" class="header-anchor"></a></h1><p><a href="https://github.com/JetRunner/BERT-of-Theseus" target="_blank" rel="noopener">论文原作者配图</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NLP" scheme="https://xv44586.github.io/categories/NLP/"/>
    
    
      <category term="BERT" scheme="https://xv44586.github.io/tags/BERT/"/>
    
      <category term="Distillation" scheme="https://xv44586.github.io/tags/Distillation/"/>
    
  </entry>
  
</feed>
